// Comprehensive type conflict test cases for v1
// This file covers supported conflict types for testing
syntax = "proto2";

package space.alnovis.protowrapper.it.proto.v1;

option java_package = "space.alnovis.protowrapper.it.proto.v1";
option java_outer_classname = "Conflicts";

import "v1/common.proto";

// =============================================================================
// INT_ENUM CONFLICTS (int32 in v1 -> enum in v2)
// =============================================================================

message IntEnumConflicts {
    // Case 1: Simple int to enum
    required int32 status = 1;           // -> ConflictStatusEnum in v2

    // Case 2: Optional int to enum
    optional int32 priority = 2;         // -> ConflictPriorityEnum in v2

    // Case 3: Repeated int to enum
    repeated int32 categories = 3;       // -> repeated CategoryEnum in v2

    // Non-conflicting fields
    required string name = 10;
    optional int32 version = 11;
}

// =============================================================================
// WIDENING CONFLICTS (smaller type -> larger type)
// =============================================================================

message WideningConflicts {
    // Case 1: int32 -> int64
    required int32 small_counter = 1;    // -> int64 in v2

    // Case 2: int32 -> double
    required int32 integer_value = 2;    // -> double in v2

    // Case 3: float -> double
    required float single_precision = 3; // -> double in v2

    // Case 4: sint32 -> sint64
    optional sint32 signed_small = 4;    // -> sint64 in v2

    // Case 5: uint32 -> uint64
    optional uint32 unsigned_small = 5;  // -> uint64 in v2

    // Non-conflicting
    required string identifier = 10;
    optional string description = 11;
}

// =============================================================================
// STRING_BYTES CONFLICTS
// =============================================================================

message StringBytesConflicts {
    // Case 1: string in v1 -> bytes in v2
    required string text_data = 1;       // -> bytes in v2

    // Case 2: Optional string -> bytes
    optional string optional_text = 2;   // -> bytes in v2

    // Case 3: Repeated string -> bytes
    repeated string text_list = 3;       // -> repeated bytes in v2

    // Non-conflicting
    required string identifier = 10;
    optional string label = 11;
}

// =============================================================================
// PRIMITIVE_MESSAGE CONFLICTS (primitive -> message)
// =============================================================================

message PrimitiveMessageConflicts {
    // Case 1: int32 in v1 -> message in v2
    required int32 simple_ref = 1;       // -> RefInfo message in v2

    // Case 2: string in v1 -> message in v2
    required string text_ref = 2;        // -> TextInfo message in v2

    // Case 3: int64 in v1 -> message in v2
    optional int64 timestamp_value = 3;  // -> TimestampInfo message in v2

    // Non-conflicting
    required string name = 10;
    optional string code = 11;
}

// =============================================================================
// MULTIPLE CONFLICTS IN SAME MESSAGE
// =============================================================================

message MultipleConflicts {
    // INT_ENUM conflicts
    required int32 status = 1;           // -> ConflictStatusEnum in v2
    required int32 priority = 2;         // -> ConflictPriorityEnum in v2

    // WIDENING conflicts
    required int32 count = 3;            // -> int64 in v2
    required float ratio = 4;            // -> double in v2

    // STRING_BYTES conflict
    required string payload = 5;         // -> bytes in v2

    // PRIMITIVE_MESSAGE conflict
    optional int32 reference = 6;        // -> ReferenceInfo in v2

    // Non-conflicting
    required string id = 10;
    optional string name = 11;
}

// =============================================================================
// REPEATED FIELD CONFLICTS
// =============================================================================

message RepeatedConflicts {
    // Repeated int32 -> repeated int64 (WIDENING)
    repeated int32 numbers = 1;          // -> repeated int64 in v2

    // Repeated int32 -> repeated enum (INT_ENUM)
    repeated int32 codes = 2;            // -> repeated CodeEnum in v2

    // Repeated string -> repeated bytes (STRING_BYTES)
    repeated string texts = 3;           // -> repeated bytes in v2

    // Repeated float -> repeated double (WIDENING)
    repeated float values = 4;           // -> repeated double in v2

    required string batch_id = 10;
}

// =============================================================================
// VERSION-SPECIFIC FIELDS
// =============================================================================

message VersionSpecificFields {
    // Common fields
    required string id = 1;
    required string name = 2;

    // V1-only fields (removed in v2)
    optional string legacy_code = 3;
    optional int32 old_format = 4;

    // Fields that exist in both but with conflicts
    required int32 status = 5;           // -> ConflictStatusEnum in v2

    optional string description = 10;
}

// =============================================================================
// ENUM VALUE CONFLICTS (same enum name, different values)
// =============================================================================

enum SharedEnumV1 {
    SHARED_UNKNOWN = 0;
    SHARED_VALUE_A = 1;
    SHARED_VALUE_B = 2;
    // VALUE_C and VALUE_D don't exist in v1
}

message EnumValueConflicts {
    required SharedEnumV1 shared_type = 1;  // Same enum name, different values
    required string data = 2;
}

// =============================================================================
// SIMPLE NESTED CONFLICTS (without builder complexity)
// =============================================================================

message SimpleNestedConflicts {
    required string id = 1;

    // Nested message that will have type changes in v2
    message InnerData {
        required int32 value = 1;        // -> int64 in v2 (WIDENING)
        required int32 type_code = 2;    // -> TypeEnum in v2 (INT_ENUM)
        optional string data = 3;        // -> bytes in v2 (STRING_BYTES)
    }

    required InnerData data = 2;
    optional string description = 10;
}

// =============================================================================
// NESTED PRIMITIVE_MESSAGE CONFLICTS
// Tests the case where a nested message type is used in PRIMITIVE_MESSAGE conflict.
// This is the scenario that was broken with ParentTicket in domain project.
// =============================================================================

message NestedPrimitiveMessageConflicts {
    required string id = 1;
    required string name = 2;

    // Nested message definition (will be used in v2)
    message ParentRef {
        required string ref_number = 1;
        optional string ref_type = 2;
    }

    // In v1: primitive int32
    // In v2: will become ParentRef (nested message)
    optional int32 parent_id = 3;           // -> ParentRef in v2

    // Non-conflicting fields
    optional string description = 10;
}

// =============================================================================
// FLOAT_DOUBLE CONFLICTS (float -> double, separate from integer widening)
// Tests the FLOAT_DOUBLE conflict type with proper narrowing validation.
// =============================================================================

message FloatDoubleConflicts {
    // Case 1: Required float -> double
    required float temperature = 1;      // -> double in v2

    // Case 2: Optional float -> double
    optional float pressure = 2;         // -> double in v2

    // Case 3: Multiple float fields
    required float humidity = 3;         // -> double in v2
    optional float wind_speed = 4;       // -> double in v2

    // Non-conflicting fields
    required string sensor_id = 10;
    optional string location = 11;
}

// =============================================================================
// SIGNED_UNSIGNED CONFLICTS (int32 -> uint32, sint32 vs int32, etc.)
// Tests the SIGNED_UNSIGNED conflict type where Java types are the same (int/long)
// but protobuf types differ in signedness semantics.
// =============================================================================

message SignedUnsignedConflicts {
    // Case 1: int32 (signed) -> uint32 (unsigned) in v2
    // Both map to Java int, but uint32 can have values > Integer.MAX_VALUE
    required int32 counter = 1;          // -> uint32 in v2

    // Case 2: Optional int32 -> uint32
    optional int32 optional_count = 2;   // -> uint32 in v2

    // Case 3: sint32 (ZigZag) -> int32 (varint) in v2
    // Different wire encodings for negative numbers
    optional sint32 delta = 3;           // -> int32 in v2

    // Case 4: sfixed32 (signed fixed) -> fixed32 (unsigned fixed) in v2
    optional sfixed32 checksum = 4;      // -> fixed32 in v2

    // Case 5: int64 -> uint64 (64-bit signed/unsigned conflict)
    optional int64 big_counter = 5;      // -> uint64 in v2

    // Non-conflicting fields
    required string id = 10;
    optional string name = 11;
}

// =============================================================================
// REPEATED SIGNED_UNSIGNED CONFLICTS
// Tests signed/unsigned conflicts with repeated fields.
// =============================================================================

message RepeatedSignedUnsignedConflicts {
    // Repeated int32 -> repeated uint32
    repeated int32 counters = 1;         // -> repeated uint32 in v2

    // Repeated sint32 -> repeated int32
    repeated sint32 deltas = 2;          // -> repeated int32 in v2

    // Repeated int64 -> repeated uint64
    repeated int64 big_counters = 3;     // -> repeated uint64 in v2

    required string batch_id = 10;
}

// =============================================================================
// PURE BYTES FIELDS (no conflict - bytes in both versions)
// Tests that bytes fields work correctly in builders.
// This is the scenario that was broken: byte[] -> ByteString conversion missing.
// =============================================================================

message BytesFieldsTest {
    required string id = 1;

    // Case 1: Required bytes field
    required bytes binary_data = 2;

    // Case 2: Optional bytes field
    optional bytes optional_binary = 3;

    // Case 3: Repeated bytes field
    repeated bytes binary_list = 4;

    // Case 4: Bytes field in nested message
    message BinaryPayload {
        required bytes content = 1;
        optional bytes signature = 2;
        optional string content_type = 3;
    }

    optional BinaryPayload payload = 5;

    // Non-conflicting fields
    optional string description = 10;
}

// =============================================================================
// REPEATED_SINGLE CONFLICTS (repeated in v1 -> singular in v2)
// Tests the REPEATED_SINGLE conflict type where cardinality differs.
// =============================================================================

message RepeatedSingleConflicts {
    // Case 1: repeated int32 in v1 -> optional int32 in v2
    repeated int32 items = 1;            // -> optional int32 item in v2

    // Case 2: repeated string in v1 -> optional string in v2
    repeated string tags = 2;            // -> optional string tag in v2

    // Case 3: repeated float in v1 -> optional float in v2
    repeated float scores = 3;           // -> optional float score in v2

    // Non-conflicting fields
    required string id = 10;
    optional string name = 11;
}

// =============================================================================
// NESTED ALL CONFLICTS
// Comprehensive test for ALL conflict types in nested structures.
// Tests WIDENING, INT_ENUM, STRING_BYTES, FLOAT_DOUBLE, SIGNED_UNSIGNED in nested message.
// =============================================================================

message NestedAllConflicts {
    required string id = 1;

    // Nested message with ALL types of conflicts
    message NestedData {
        // WIDENING: int32 -> int64
        required int32 widening_value = 1;    // -> int64 in v2

        // INT_ENUM: int32 -> enum
        required int32 enum_code = 2;         // -> CodeEnum in v2

        // STRING_BYTES: string -> bytes
        optional string text_data = 3;        // -> bytes in v2

        // FLOAT_DOUBLE: float -> double
        required float precision = 4;         // -> double in v2

        // SIGNED_UNSIGNED: int32 -> uint32
        required int32 counter = 5;           // -> uint32 in v2

        // Non-conflicting
        optional string label = 10;
    }

    required NestedData data = 2;
    optional string description = 10;
}

// =============================================================================
// OPTIONAL_REQUIRED CONFLICTS (optional in v1 -> required in v2)
// =============================================================================

message OptionalRequiredConflicts {
    // Case 1: optional in v1, required in v2
    optional string name = 1;

    // Case 2: optional int in v1, required in v2
    optional int32 count = 2;

    // Case 3: optional message in v1, required in v2
    optional Date timestamp = 3;

    // Non-conflicting: required in both versions
    required string id = 10;
}

