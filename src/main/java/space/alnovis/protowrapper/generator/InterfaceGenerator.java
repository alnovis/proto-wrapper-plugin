package space.alnovis.protowrapper.generator;

import com.squareup.javapoet.*;
import space.alnovis.protowrapper.model.MergedSchema;
import space.alnovis.protowrapper.model.MergedSchema.MergedField;
import space.alnovis.protowrapper.model.MergedSchema.MergedMessage;

import javax.lang.model.element.Modifier;
import java.io.IOException;
import java.nio.file.Path;

/**
 * Generates version-agnostic Java interfaces from merged schema.
 *
 * <p>Example output:</p>
 * <pre>
 * public interface Money {
 *     long getBills();
 *     int getCoins();
 *     long toKopecks();
 * }
 * </pre>
 */
public class InterfaceGenerator {

    private final GeneratorConfig config;
    private MergedSchema schema;

    public InterfaceGenerator(GeneratorConfig config) {
        this.config = config;
    }

    /**
     * Set the merged schema for cross-message type resolution.
     * @param schema The merged schema
     */
    public void setSchema(MergedSchema schema) {
        this.schema = schema;
    }

    /**
     * Generate interface for a merged message.
     *
     * @param message Merged message info
     * @return Generated JavaFile
     */
    public JavaFile generate(MergedMessage message) {
        TypeSpec.Builder interfaceBuilder = TypeSpec.interfaceBuilder(message.getInterfaceName())
                .addModifiers(Modifier.PUBLIC)
                .addJavadoc("Version-agnostic interface for $L.\n\n", message.getName())
                .addJavadoc("<p>Supported in versions: $L</p>\n", message.getPresentInVersions());

        // Add getter methods for all fields
        for (MergedField field : message.getFieldsSorted()) {
            MethodSpec getter = generateGetter(field, message);
            interfaceBuilder.addMethod(getter);

            // Add hasXxx method for optional fields
            if (field.isOptional() && !field.isRepeated()) {
                interfaceBuilder.addMethod(generateHasMethod(field));
            }
        }

        // Add nested enums first
        for (MergedSchema.MergedEnum nestedEnum : message.getNestedEnums()) {
            TypeSpec enumSpec = generateNestedEnum(nestedEnum);
            interfaceBuilder.addType(enumSpec);
        }

        // Add nested interfaces for nested messages
        for (MergedMessage nested : message.getNestedMessages()) {
            TypeSpec nestedInterface = generateNestedInterface(nested);
            interfaceBuilder.addType(nestedInterface);
        }

        // Add common utility methods
        addCommonMethods(interfaceBuilder, message);

        TypeSpec interfaceSpec = interfaceBuilder.build();

        return JavaFile.builder(config.getApiPackage(), interfaceSpec)
                .addFileComment("Generated by proto-wrapper-maven-plugin. DO NOT EDIT.")
                .indent("    ")
                .build();
    }

    private MethodSpec generateGetter(MergedField field, MergedMessage message) {
        TypeName returnType = parseFieldType(field, message);

        MethodSpec.Builder builder = MethodSpec.methodBuilder(field.getGetterName())
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .returns(returnType);

        // Add javadoc
        if (!field.isUniversal(message.getPresentInVersions())) {
            builder.addJavadoc("@return $L value, or null if not present in this version\n",
                    field.getJavaName());
            builder.addJavadoc("@apiNote Present in versions: $L\n", field.getPresentInVersions());
        } else {
            builder.addJavadoc("@return $L value\n", field.getJavaName());
        }

        return builder.build();
    }

    private MethodSpec generateHasMethod(MergedField field) {
        return MethodSpec.methodBuilder("has" + capitalize(field.getJavaName()))
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .returns(TypeName.BOOLEAN)
                .addJavadoc("Check if $L is present.\n", field.getJavaName())
                .addJavadoc("@return true if the field has a value\n")
                .build();
    }

    private TypeSpec generateNestedInterface(MergedMessage nested) {
        TypeSpec.Builder builder = TypeSpec.interfaceBuilder(nested.getInterfaceName())
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .addJavadoc("Nested interface for $L.\n", nested.getName());

        // Add getter methods for all fields
        for (MergedField field : nested.getFieldsSorted()) {
            TypeName returnType = parseFieldType(field, nested);
            MethodSpec getter = MethodSpec.methodBuilder(field.getGetterName())
                    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                    .returns(returnType)
                    .build();
            builder.addMethod(getter);

            // Add hasXxx method for optional fields
            if (field.isOptional() && !field.isRepeated()) {
                builder.addMethod(MethodSpec.methodBuilder("has" + capitalize(field.getJavaName()))
                        .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                        .returns(TypeName.BOOLEAN)
                        .build());
            }
        }

        // Add nested enums first (before nested interfaces)
        for (MergedSchema.MergedEnum nestedEnum : nested.getNestedEnums()) {
            TypeSpec enumSpec = generateNestedEnum(nestedEnum);
            builder.addType(enumSpec);
        }

        // Recursively add deeply nested interfaces (e.g., Item.Commodity, Domain.Services)
        for (MergedMessage deeplyNested : nested.getNestedMessages()) {
            TypeSpec deeplyNestedInterface = generateNestedInterface(deeplyNested);
            builder.addType(deeplyNestedInterface);
        }

        return builder.build();
    }

    /**
     * Generate a nested enum as a TypeSpec for embedding in an interface.
     */
    private TypeSpec generateNestedEnum(MergedSchema.MergedEnum enumInfo) {
        TypeSpec.Builder enumBuilder = TypeSpec.enumBuilder(enumInfo.getName())
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .addJavadoc("Nested enum for $L.\n", enumInfo.getName());

        // Add value field
        enumBuilder.addField(TypeName.INT, "value", Modifier.PRIVATE, Modifier.FINAL);

        // Add constructor
        enumBuilder.addMethod(MethodSpec.constructorBuilder()
                .addParameter(TypeName.INT, "value")
                .addStatement("this.value = value")
                .build());

        // Add getValue() method
        enumBuilder.addMethod(MethodSpec.methodBuilder("getValue")
                .addModifiers(Modifier.PUBLIC)
                .returns(TypeName.INT)
                .addStatement("return value")
                .build());

        // Add fromProtoValue() method
        enumBuilder.addMethod(MethodSpec.methodBuilder("fromProtoValue")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(ClassName.get("", enumInfo.getName()))
                .addParameter(TypeName.INT, "value")
                .beginControlFlow("for ($L e : values())", enumInfo.getName())
                .beginControlFlow("if (e.value == value)")
                .addStatement("return e")
                .endControlFlow()
                .endControlFlow()
                .addStatement("return null")
                .build());

        // Add enum constants
        for (MergedSchema.MergedEnumValue value : enumInfo.getValues()) {
            enumBuilder.addEnumConstant(value.getName(),
                    TypeSpec.anonymousClassBuilder("$L", value.getNumber()).build());
        }

        return enumBuilder.build();
    }

    private void addCommonMethods(TypeSpec.Builder builder, MergedMessage message) {
        // Add getWrapperVersion() method - renamed to avoid conflict with protocol_version field
        builder.addMethod(MethodSpec.methodBuilder("getWrapperVersion")
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .returns(TypeName.INT)
                .addJavadoc("Get the wrapper protocol version this instance was created from.\n")
                .addJavadoc("@return Protocol version (e.g., 202, 203)\n")
                .build());

        // Add toBytes() method
        builder.addMethod(MethodSpec.methodBuilder("toBytes")
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .returns(ArrayTypeName.of(TypeName.BYTE))
                .addJavadoc("Serialize to protobuf bytes.\n")
                .addJavadoc("@return Protobuf-encoded bytes\n")
                .build());

        // Add asVersion() method for type conversion
        TypeVariableName typeVar = TypeVariableName.get("T", ClassName.get(config.getApiPackage(), message.getInterfaceName()));
        builder.addMethod(MethodSpec.methodBuilder("asVersion")
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .addTypeVariable(typeVar)
                .returns(typeVar)
                .addParameter(ParameterizedTypeName.get(ClassName.get(Class.class), typeVar), "versionClass")
                .addJavadoc("Convert to a specific version implementation.\n")
                .addJavadoc("@param versionClass Target version class\n")
                .addJavadoc("@return Instance of the specified version\n")
                .build());
    }

    /**
     * Parse field type using the full nested type path from proto type name.
     * This method extracts the full path (e.g., "Order.ShippingInfo") to properly
     * resolve cross-message nested type references.
     */
    private TypeName parseFieldType(MergedField field, MergedMessage context) {
        String getterType = field.getGetterType();

        // Handle primitives
        switch (getterType) {
            case "int": return TypeName.INT;
            case "long": return TypeName.LONG;
            case "double": return TypeName.DOUBLE;
            case "float": return TypeName.FLOAT;
            case "boolean": return TypeName.BOOLEAN;
            case "byte[]": return ArrayTypeName.of(TypeName.BYTE);
            case "String": return ClassName.get(String.class);
            case "Integer": return ClassName.get(Integer.class);
            case "Long": return ClassName.get(Long.class);
            case "Double": return ClassName.get(Double.class);
            case "Float": return ClassName.get(Float.class);
            case "Boolean": return ClassName.get(Boolean.class);
        }

        // Handle List<T> - need to extract full type path for the inner type
        if (getterType.startsWith("java.util.List<")) {
            // Extract the inner type from the getter type
            String innerTypeName = getterType.substring("java.util.List<".length(), getterType.length() - 1);

            // Check if it's a primitive/wrapper type first
            TypeName innerType = parsePrimitiveOrWrapperType(innerTypeName);
            if (innerType != null) {
                return ParameterizedTypeName.get(ClassName.get(java.util.List.class), innerType);
            }

            // For message/enum types, use the full nested type path
            String protoPackage = extractProtoPackage(config.getProtoPackagePattern());
            String fullTypePath = field.getNestedTypePath(protoPackage);
            innerType = resolveNestedType(fullTypePath, context);
            return ParameterizedTypeName.get(ClassName.get(java.util.List.class), innerType);
        }

        // For message and enum types, use full nested type path
        String protoPackage = extractProtoPackage(config.getProtoPackagePattern());
        String fullTypePath = field.getNestedTypePath(protoPackage);
        return resolveNestedType(fullTypePath, context);
    }

    /**
     * Parse primitive and wrapper types. Returns null if not a primitive/wrapper type.
     */
    private TypeName parsePrimitiveOrWrapperType(String typeName) {
        switch (typeName) {
            case "int": return TypeName.INT;
            case "long": return TypeName.LONG;
            case "double": return TypeName.DOUBLE;
            case "float": return TypeName.FLOAT;
            case "boolean": return TypeName.BOOLEAN;
            case "byte[]": return ArrayTypeName.of(TypeName.BYTE);
            case "String": return ClassName.get(String.class);
            case "Integer": return ClassName.get(Integer.class);
            case "Long": return ClassName.get(Long.class);
            case "Double": return ClassName.get(Double.class);
            case "Float": return ClassName.get(Float.class);
            case "Boolean": return ClassName.get(Boolean.class);
            default: return null;
        }
    }

    /**
     * Extract the proto package from the pattern by using a sample version.
     * Note: proto package is typically the last 3 parts of java_package (e.g., "example.proto.v1")
     * when java_package is "com.example.proto.v1"
     */
    private String extractProtoPackage(String pattern) {
        if (pattern == null || pattern.isEmpty()) {
            return "";
        }
        // The java_package pattern is like "com.example.proto.{version}"
        // The proto package is typically "example.proto.{version}"
        // We need to extract just the proto package part
        String javaPackage = pattern.replace("{version}", "v1");

        // Try to extract the proto package by finding the common suffix
        // Proto packages typically start with a domain-like structure (example.proto.version)
        String[] parts = javaPackage.split("\\.");
        if (parts.length >= 3) {
            // Take the last 3 parts (or more if there's subpackaging)
            // e.g., "com.example.proto.v1" -> "example.proto.v1"
            StringBuilder protoPackage = new StringBuilder();
            for (int i = Math.max(0, parts.length - 3); i < parts.length; i++) {
                if (protoPackage.length() > 0) {
                    protoPackage.append(".");
                }
                protoPackage.append(parts[i]);
            }
            return protoPackage.toString();
        }

        return javaPackage;
    }

    private TypeName parseTypeName(String typeName, MergedMessage context) {
        // Handle primitives
        switch (typeName) {
            case "int": return TypeName.INT;
            case "long": return TypeName.LONG;
            case "double": return TypeName.DOUBLE;
            case "float": return TypeName.FLOAT;
            case "boolean": return TypeName.BOOLEAN;
            case "byte[]": return ArrayTypeName.of(TypeName.BYTE);
            case "String": return ClassName.get(String.class);
            case "Integer": return ClassName.get(Integer.class);
            case "Long": return ClassName.get(Long.class);
            case "Double": return ClassName.get(Double.class);
            case "Float": return ClassName.get(Float.class);
            case "Boolean": return ClassName.get(Boolean.class);
        }

        // Handle List<T>
        if (typeName.startsWith("java.util.List<")) {
            String inner = typeName.substring("java.util.List<".length(), typeName.length() - 1);
            TypeName innerType = parseTypeName(inner, context);
            return ParameterizedTypeName.get(ClassName.get(java.util.List.class), innerType);
        }

        // Try to resolve nested types
        return resolveNestedType(typeName, context);
    }

    /**
     * Resolve a type that might be nested within the current context, its ancestors, or other messages.
     */
    private TypeName resolveNestedType(String typeName, MergedMessage context) {
        // If typeName contains dots, it might be a cross-message path like "Order.ShippingInfo"
        if (typeName.contains(".")) {
            // Check if this nested path has an equivalent top-level enum
            if (schema != null && schema.hasEquivalentTopLevelEnum(typeName)) {
                String topLevelName = schema.getEquivalentTopLevelEnum(typeName);
                return ClassName.get(config.getApiPackage(), topLevelName);
            }
            return resolveCrossMessageType(typeName, context);
        }

        // Check if it's a direct nested message of the current context
        for (MergedMessage nested : context.getNestedMessages()) {
            if (nested.getName().equals(typeName)) {
                // Direct child - just use simple name (will resolve within the interface)
                return ClassName.get("", typeName);
            }
        }

        // Check if it's a direct nested enum of the current context
        java.util.Optional<MergedSchema.MergedEnum> directEnum = context.findNestedEnum(typeName);
        if (directEnum.isPresent()) {
            // Direct child enum - just use simple name
            return ClassName.get("", typeName);
        }

        // Check if nested enum with this name has an equivalent top-level enum
        String nestedPath = context.getQualifiedInterfaceName() + "." + typeName;
        if (schema != null && schema.hasEquivalentTopLevelEnum(nestedPath)) {
            String topLevelName = schema.getEquivalentTopLevelEnum(nestedPath);
            return ClassName.get(config.getApiPackage(), topLevelName);
        }

        // Check if it's a sibling nested message or enum (same parent)
        MergedMessage parent = context.getParent();
        if (parent != null) {
            // Check sibling messages
            for (MergedMessage sibling : parent.getNestedMessages()) {
                if (sibling.getName().equals(typeName)) {
                    // Sibling message - reference as ParentName.SiblingName
                    return buildRelativeNestedClassName(parent.getName() + "." + typeName);
                }
                // Check sibling's nested messages
                java.util.Optional<MergedMessage> found = sibling.findNestedMessageRecursive(typeName);
                if (found.isPresent()) {
                    String path = sibling.getName() + "." + found.get().getQualifiedInterfaceName().replace(sibling.getName() + ".", "");
                    return buildRelativeNestedClassName(path);
                }
                // Check sibling's nested enums
                java.util.Optional<MergedSchema.MergedEnum> siblingEnum = sibling.findNestedEnumRecursive(typeName);
                if (siblingEnum.isPresent()) {
                    return buildRelativeNestedClassName(sibling.getName() + "." + typeName);
                }
            }
            // Check sibling enums
            java.util.Optional<MergedSchema.MergedEnum> siblingEnum = parent.findNestedEnum(typeName);
            if (siblingEnum.isPresent()) {
                return buildRelativeNestedClassName(parent.getName() + "." + typeName);
            }
        }

        // Check if it's anywhere in the top-level parent hierarchy
        MergedMessage topLevel = context.getTopLevelParent();
        if (topLevel != context) {
            // Check nested messages
            java.util.Optional<MergedMessage> found = topLevel.findNestedMessageRecursive(typeName);
            if (found.isPresent()) {
                String qualifiedPath = found.get().getQualifiedInterfaceName();
                return buildRelativeNestedClassName(qualifiedPath);
            }
            // Check nested enums
            java.util.Optional<MergedSchema.MergedEnum> foundEnum = topLevel.findNestedEnumRecursive(typeName);
            if (foundEnum.isPresent()) {
                // Need to find the path to this enum - for now just use top level + enum name
                // This is simplified - ideally we'd track the full path
                return buildRelativeNestedClassName(topLevel.getName() + "." + typeName);
            }
        }

        // Not a nested type - assume it's in the API package (top-level interface)
        return ClassName.get(config.getApiPackage(), typeName);
    }

    /**
     * Resolve a cross-message type path like "Order.ShippingInfo".
     * The path indicates a nested type in another top-level message.
     */
    private TypeName resolveCrossMessageType(String typePath, MergedMessage context) {
        String[] parts = typePath.split("\\.");

        // First part is the parent message name
        String parentMessageName = parts[0];

        // Check if this is within our own context hierarchy
        MergedMessage topLevel = context.getTopLevelParent();
        if (topLevel.getName().equals(parentMessageName)) {
            // It's within our own message hierarchy - resolve relative to top-level
            java.util.Optional<MergedMessage> found = topLevel.findNestedMessageRecursive(parts[parts.length - 1]);
            if (found.isPresent()) {
                return buildRelativeNestedClassName(found.get().getQualifiedInterfaceName());
            }
            java.util.Optional<MergedSchema.MergedEnum> foundEnum = topLevel.findNestedEnumRecursive(parts[parts.length - 1]);
            if (foundEnum.isPresent()) {
                // Rebuild path from parts
                return buildRelativeNestedClassName(typePath);
            }
        }

        // It's a cross-message reference - need to use full package path
        if (schema != null) {
            // Try to find the nested message in the schema
            java.util.Optional<MergedMessage> crossMessage = schema.findMessageByPath(typePath);
            if (crossMessage.isPresent()) {
                // Found it - build full class reference
                return buildNestedClassName(typePath);
            }

            // Try to find as a nested enum
            java.util.Optional<MergedSchema.MergedEnum> crossEnum = schema.findEnumByPath(typePath);
            if (crossEnum.isPresent()) {
                return buildNestedClassName(typePath);
            }
        }

        // Fallback: assume it's a valid path and generate the reference
        return buildNestedClassName(typePath);
    }

    /**
     * Build a nested class name with the API package.
     * E.g., "Order.ShippingInfo" -> ClassName(apiPackage, "Order").nestedClass("ShippingInfo")
     */
    private ClassName buildNestedClassName(String qualifiedPath) {
        String[] parts = qualifiedPath.split("\\.");
        if (parts.length == 1) {
            return ClassName.get(config.getApiPackage(), parts[0]);
        }
        ClassName result = ClassName.get(config.getApiPackage(), parts[0]);
        for (int i = 1; i < parts.length; i++) {
            result = result.nestedClass(parts[i]);
        }
        return result;
    }

    /**
     * Build a relative nested class name for use within interface definitions.
     * E.g., "Order.Tax" -> ClassName with no package that resolves to Order.Tax
     */
    private ClassName buildRelativeNestedClassName(String qualifiedPath) {
        String[] parts = qualifiedPath.split("\\.");
        if (parts.length == 1) {
            return ClassName.get("", parts[0]);
        }
        // Build nested class reference without package
        ClassName result = ClassName.get("", parts[0]);
        for (int i = 1; i < parts.length; i++) {
            result = result.nestedClass(parts[i]);
        }
        return result;
    }

    private String capitalize(String s) {
        if (s == null || s.isEmpty()) return s;
        return Character.toUpperCase(s.charAt(0)) + s.substring(1);
    }

    /**
     * Write generated interface to file.
     *
     * @param javaFile Generated Java file
     * @throws IOException if writing fails
     */
    public void writeToFile(JavaFile javaFile) throws IOException {
        javaFile.writeTo(config.getOutputDirectory());
    }

    /**
     * Generate and write interface.
     *
     * @param message Message to generate interface for
     * @return Path to generated file
     * @throws IOException if writing fails
     */
    public Path generateAndWrite(MergedMessage message) throws IOException {
        JavaFile javaFile = generate(message);
        writeToFile(javaFile);

        String relativePath = config.getApiPackage().replace('.', '/')
                + "/" + message.getInterfaceName() + ".java";
        return config.getOutputDirectory().resolve(relativePath);
    }
}
