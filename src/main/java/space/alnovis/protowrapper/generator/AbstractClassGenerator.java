package space.alnovis.protowrapper.generator;

import com.squareup.javapoet.*;
import space.alnovis.protowrapper.model.MergedSchema;
import space.alnovis.protowrapper.model.MergedSchema.MergedField;
import space.alnovis.protowrapper.model.MergedSchema.MergedMessage;

import javax.lang.model.element.Modifier;
import java.io.IOException;
import java.nio.file.Path;

/**
 * Generates abstract base classes using template method pattern.
 *
 * <p>Example output:</p>
 * <pre>
 * public abstract class AbstractMoney&lt;PROTO extends Message&gt;
 *         extends AbstractProtoWrapper&lt;PROTO&gt;
 *         implements Money {
 *
 *     protected AbstractMoney(PROTO proto) {
 *         super(proto);
 *     }
 *
 *     protected abstract long extractBills(PROTO proto);
 *     protected abstract int extractCoins(PROTO proto);
 *
 *     &#64;Override
 *     public final long getBills() {
 *         return extractBills(proto);
 *     }
 *
 *     &#64;Override
 *     public final int getCoins() {
 *         return extractCoins(proto);
 *     }
 * }
 * </pre>
 */
public class AbstractClassGenerator {

    private final GeneratorConfig config;
    private MergedSchema schema;

    public AbstractClassGenerator(GeneratorConfig config) {
        this.config = config;
    }

    /**
     * Set the merged schema for cross-message type resolution.
     */
    public void setSchema(MergedSchema schema) {
        this.schema = schema;
    }

    /**
     * Generate abstract class for a merged message.
     *
     * @param message Merged message info
     * @return Generated JavaFile
     */
    public JavaFile generate(MergedMessage message) {
        String className = message.getAbstractClassName();
        String interfaceName = message.getInterfaceName();

        // Type parameter: PROTO extends Message
        TypeVariableName protoType = TypeVariableName.get("PROTO",
                ClassName.get("com.google.protobuf", "Message"));

        // Interface: Money (or whatever)
        ClassName interfaceType = ClassName.get(config.getApiPackage(), interfaceName);

        TypeSpec.Builder classBuilder = TypeSpec.classBuilder(className)
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .addTypeVariable(protoType)
                .addSuperinterface(interfaceType)
                .addJavadoc("Abstract base class for $L implementations.\n\n", interfaceName)
                .addJavadoc("<p>Uses template method pattern - subclasses implement extract* methods.</p>\n")
                .addJavadoc("@param <PROTO> Protocol-specific message type\n");

        // Add protected field for convenient access
        classBuilder.addField(FieldSpec.builder(protoType, "proto", Modifier.PROTECTED, Modifier.FINAL)
                .addJavadoc("The underlying proto message.\n")
                .build());

        // Constructor
        classBuilder.addMethod(MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PROTECTED)
                .addParameter(protoType, "proto")
                .addStatement("this.proto = proto")
                .build());

        // Add abstract extract methods
        classBuilder.addJavadoc("\n// ========== Abstract Extract Methods ==========\n\n");
        for (MergedField field : message.getFieldsSorted()) {
            addExtractMethods(classBuilder, field, protoType, message);
        }

        // Add concrete getter implementations
        classBuilder.addJavadoc("\n// ========== Concrete Getter Implementations ==========\n\n");
        for (MergedField field : message.getFieldsSorted()) {
            addGetterImplementation(classBuilder, field, message);
        }

        // Add common methods
        addCommonMethods(classBuilder, message, protoType);

        TypeSpec classSpec = classBuilder.build();

        return JavaFile.builder(config.getApiPackage() + ".impl", classSpec)
                .addFileComment("Generated by proto-wrapper-maven-plugin. DO NOT EDIT.")
                .indent("    ")
                .build();
    }

    private void addExtractMethods(TypeSpec.Builder classBuilder, MergedField field,
                                   TypeVariableName protoType, MergedMessage message) {
        TypeName returnType = parseFieldType(field, message);

        // For optional fields (not repeated), add extractHas method
        if (field.isOptional() && !field.isRepeated()) {
            classBuilder.addMethod(MethodSpec.methodBuilder(field.getExtractHasMethodName())
                    .addModifiers(Modifier.PROTECTED, Modifier.ABSTRACT)
                    .returns(TypeName.BOOLEAN)
                    .addParameter(protoType, "proto")
                    .build());
        }

        // Main extract method
        classBuilder.addMethod(MethodSpec.methodBuilder(field.getExtractMethodName())
                .addModifiers(Modifier.PROTECTED, Modifier.ABSTRACT)
                .returns(returnType)
                .addParameter(protoType, "proto")
                .build());
    }

    private void addGetterImplementation(TypeSpec.Builder classBuilder, MergedField field,
                                         MergedMessage message) {
        TypeName returnType = parseFieldType(field, message);

        MethodSpec.Builder getter = MethodSpec.methodBuilder(field.getGetterName())
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .returns(returnType);

        // For optional primitives, use has-check pattern to return boxed null
        if (field.needsHasCheck()) {
            getter.addStatement("return $L(proto) ? $L(proto) : null",
                    field.getExtractHasMethodName(), field.getExtractMethodName());
        } else {
            getter.addStatement("return $L(proto)", field.getExtractMethodName());
        }

        classBuilder.addMethod(getter.build());

        // Add hasXxx method for optional fields (not repeated)
        if (field.isOptional() && !field.isRepeated()) {
            MethodSpec has = MethodSpec.methodBuilder("has" + capitalize(field.getJavaName()))
                    .addAnnotation(Override.class)
                    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                    .returns(TypeName.BOOLEAN)
                    .addStatement("return $L(proto)", field.getExtractHasMethodName())
                    .build();
            classBuilder.addMethod(has);
        }
    }

    private void addCommonMethods(TypeSpec.Builder classBuilder, MergedMessage message,
                                  TypeVariableName protoType) {
        // Abstract method for serialization
        classBuilder.addMethod(MethodSpec.methodBuilder("serializeToBytes")
                .addModifiers(Modifier.PROTECTED, Modifier.ABSTRACT)
                .returns(ArrayTypeName.of(TypeName.BYTE))
                .addParameter(protoType, "proto")
                .build());

        // toBytes() implementation
        classBuilder.addMethod(MethodSpec.methodBuilder("toBytes")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .returns(ArrayTypeName.of(TypeName.BYTE))
                .addStatement("return serializeToBytes(proto)")
                .build());

        // Abstract getWrapperVersion - renamed to avoid conflict with protocol_version field
        classBuilder.addMethod(MethodSpec.methodBuilder("extractWrapperVersion")
                .addModifiers(Modifier.PROTECTED, Modifier.ABSTRACT)
                .returns(TypeName.INT)
                .addParameter(protoType, "proto")
                .build());

        // getWrapperVersion() implementation
        classBuilder.addMethod(MethodSpec.methodBuilder("getWrapperVersion")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .returns(TypeName.INT)
                .addStatement("return extractWrapperVersion(proto)")
                .build());

        // asVersion() implementation using converter
        String interfaceName = message.getInterfaceName();
        TypeVariableName typeVar = TypeVariableName.get("T",
                ClassName.get(config.getApiPackage(), interfaceName));

        classBuilder.addMethod(MethodSpec.methodBuilder("asVersion")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addTypeVariable(typeVar)
                .returns(typeVar)
                .addParameter(ParameterizedTypeName.get(ClassName.get(Class.class), typeVar), "versionClass")
                .addStatement("return convertToVersion(versionClass)")
                .build());

        // Protected helper method for conversion
        classBuilder.addMethod(MethodSpec.methodBuilder("convertToVersion")
                .addModifiers(Modifier.PROTECTED)
                .addTypeVariable(typeVar)
                .returns(typeVar)
                .addParameter(ParameterizedTypeName.get(ClassName.get(Class.class), typeVar), "versionClass")
                .addJavadoc("Override in subclass to implement version conversion.\n")
                .addStatement("throw new $T($S + versionClass)",
                        UnsupportedOperationException.class, "Version conversion not implemented for ")
                .build());

        // toString()
        classBuilder.addMethod(MethodSpec.methodBuilder("toString")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(String.class)
                .addStatement("return $T.format($S, getClass().getSimpleName(), getWrapperVersion())",
                        String.class, "%s[version=%d]")
                .build());
    }

    /**
     * Parse field type using the full nested type path from proto type name.
     */
    private TypeName parseFieldType(MergedField field, MergedMessage context) {
        String getterType = field.getGetterType();

        // Handle primitives
        switch (getterType) {
            case "int": return TypeName.INT;
            case "long": return TypeName.LONG;
            case "double": return TypeName.DOUBLE;
            case "float": return TypeName.FLOAT;
            case "boolean": return TypeName.BOOLEAN;
            case "byte[]": return ArrayTypeName.of(TypeName.BYTE);
            case "String": return ClassName.get(String.class);
            case "Integer": return ClassName.get(Integer.class);
            case "Long": return ClassName.get(Long.class);
            case "Double": return ClassName.get(Double.class);
            case "Float": return ClassName.get(Float.class);
            case "Boolean": return ClassName.get(Boolean.class);
        }

        // Handle List<T>
        if (getterType.startsWith("java.util.List<")) {
            // Extract the inner type from the getter type
            String innerTypeName = getterType.substring("java.util.List<".length(), getterType.length() - 1);

            // Check if it's a primitive/wrapper type first
            TypeName innerType = parsePrimitiveOrWrapperType(innerTypeName);
            if (innerType != null) {
                return ParameterizedTypeName.get(ClassName.get(java.util.List.class), innerType);
            }

            // For message/enum types, use the full nested type path
            String protoPackage = extractProtoPackage(config.getProtoPackagePattern());
            String fullTypePath = field.getNestedTypePath(protoPackage);
            innerType = resolveTypePath(fullTypePath, context);
            return ParameterizedTypeName.get(ClassName.get(java.util.List.class), innerType);
        }

        // For message and enum types, use full nested type path
        String protoPackage = extractProtoPackage(config.getProtoPackagePattern());
        String fullTypePath = field.getNestedTypePath(protoPackage);
        return resolveTypePath(fullTypePath, context);
    }

    /**
     * Parse primitive and wrapper types. Returns null if not a primitive/wrapper type.
     */
    private TypeName parsePrimitiveOrWrapperType(String typeName) {
        switch (typeName) {
            case "int": return TypeName.INT;
            case "long": return TypeName.LONG;
            case "double": return TypeName.DOUBLE;
            case "float": return TypeName.FLOAT;
            case "boolean": return TypeName.BOOLEAN;
            case "byte[]": return ArrayTypeName.of(TypeName.BYTE);
            case "String": return ClassName.get(String.class);
            case "Integer": return ClassName.get(Integer.class);
            case "Long": return ClassName.get(Long.class);
            case "Double": return ClassName.get(Double.class);
            case "Float": return ClassName.get(Float.class);
            case "Boolean": return ClassName.get(Boolean.class);
            default: return null;
        }
    }

    /**
     * Extract the proto package from the pattern.
     */
    private String extractProtoPackage(String pattern) {
        if (pattern == null || pattern.isEmpty()) {
            return "";
        }
        String javaPackage = pattern.replace("{version}", "v1");
        String[] parts = javaPackage.split("\\.");
        if (parts.length >= 3) {
            StringBuilder protoPackage = new StringBuilder();
            for (int i = Math.max(0, parts.length - 3); i < parts.length; i++) {
                if (protoPackage.length() > 0) {
                    protoPackage.append(".");
                }
                protoPackage.append(parts[i]);
            }
            return protoPackage.toString();
        }
        return javaPackage;
    }

    /**
     * Resolve a type path that might be a cross-message nested type.
     */
    private TypeName resolveTypePath(String typePath, MergedMessage context) {
        // If typePath contains dots, it might be a cross-message path like "Order.ShippingInfo"
        if (typePath.contains(".")) {
            // Check if this nested path has an equivalent top-level enum
            if (schema != null && schema.hasEquivalentTopLevelEnum(typePath)) {
                String topLevelName = schema.getEquivalentTopLevelEnum(typePath);
                return ClassName.get(config.getApiPackage(), topLevelName);
            }

            // It's a nested path - check if it's in our own hierarchy
            String[] parts = typePath.split("\\.");
            String parentMessageName = parts[0];
            MergedMessage topLevel = context.getTopLevelParent();

            if (topLevel.getName().equals(parentMessageName)) {
                // It's within our own message hierarchy
                return buildNestedClassName(typePath);
            }

            // Cross-message reference - use full path
            if (schema != null) {
                java.util.Optional<MergedMessage> crossMessage = schema.findMessageByPath(typePath);
                if (crossMessage.isPresent()) {
                    return buildNestedClassName(typePath);
                }
                java.util.Optional<MergedSchema.MergedEnum> crossEnum = schema.findEnumByPath(typePath);
                if (crossEnum.isPresent()) {
                    return buildNestedClassName(typePath);
                }
            }

            // Fallback - assume it's valid
            return buildNestedClassName(typePath);
        }

        // Simple name - check in context hierarchy first
        java.util.Optional<MergedMessage> nestedOpt = context.findNestedMessageRecursive(typePath);
        if (nestedOpt.isPresent()) {
            MergedMessage nested = nestedOpt.get();
            return buildNestedClassName(nested.getQualifiedInterfaceName());
        }

        java.util.Optional<MergedSchema.MergedEnum> nestedEnumOpt = context.findNestedEnumRecursive(typePath);
        if (nestedEnumOpt.isPresent()) {
            // Check if nested enum has an equivalent top-level
            String nestedEnumPath = context.getTopLevelParent().getName() + "." + typePath;
            if (schema != null && schema.hasEquivalentTopLevelEnum(nestedEnumPath)) {
                String topLevelName = schema.getEquivalentTopLevelEnum(nestedEnumPath);
                return ClassName.get(config.getApiPackage(), topLevelName);
            }
            return buildNestedClassName(nestedEnumPath);
        }

        if (context.isNested()) {
            MergedMessage topLevel = context.getTopLevelParent();
            java.util.Optional<MergedMessage> siblingOpt = topLevel.findNestedMessageRecursive(typePath);
            if (siblingOpt.isPresent()) {
                return buildNestedClassName(siblingOpt.get().getQualifiedInterfaceName());
            }
            java.util.Optional<MergedSchema.MergedEnum> siblingEnumOpt = topLevel.findNestedEnumRecursive(typePath);
            if (siblingEnumOpt.isPresent()) {
                // Check if sibling enum has an equivalent top-level
                String siblingEnumPath = topLevel.getName() + "." + typePath;
                if (schema != null && schema.hasEquivalentTopLevelEnum(siblingEnumPath)) {
                    String topLevelName = schema.getEquivalentTopLevelEnum(siblingEnumPath);
                    return ClassName.get(config.getApiPackage(), topLevelName);
                }
                return buildNestedClassName(siblingEnumPath);
            }
        }

        // Not a nested type - assume it's a top-level type
        return ClassName.get(config.getApiPackage(), typePath);
    }

    private TypeName parseTypeName(String typeName, MergedMessage context) {
        // Handle primitives and common types
        switch (typeName) {
            case "int": return TypeName.INT;
            case "long": return TypeName.LONG;
            case "double": return TypeName.DOUBLE;
            case "float": return TypeName.FLOAT;
            case "boolean": return TypeName.BOOLEAN;
            case "byte[]": return ArrayTypeName.of(TypeName.BYTE);
            case "String": return ClassName.get(String.class);
            case "Integer": return ClassName.get(Integer.class);
            case "Long": return ClassName.get(Long.class);
            case "Double": return ClassName.get(Double.class);
            case "Float": return ClassName.get(Float.class);
            case "Boolean": return ClassName.get(Boolean.class);
        }

        // Handle List<T>
        if (typeName.startsWith("java.util.List<")) {
            String inner = typeName.substring("java.util.List<".length(), typeName.length() - 1);
            TypeName innerType = parseTypeName(inner, context);
            return ParameterizedTypeName.get(ClassName.get(java.util.List.class), innerType);
        }

        // Use resolveTypePath for everything else
        return resolveTypePath(typeName, context);
    }

    /**
     * Build a ClassName for a nested type like "Order.Tax" or "Order.Item.Commodity".
     */
    private ClassName buildNestedClassName(String qualifiedPath) {
        String[] parts = qualifiedPath.split("\\.");
        if (parts.length == 1) {
            return ClassName.get(config.getApiPackage(), parts[0]);
        }
        // For nested classes, first part is top-level class, rest are nested
        ClassName result = ClassName.get(config.getApiPackage(), parts[0]);
        for (int i = 1; i < parts.length; i++) {
            result = result.nestedClass(parts[i]);
        }
        return result;
    }

    private String capitalize(String s) {
        if (s == null || s.isEmpty()) return s;
        return Character.toUpperCase(s.charAt(0)) + s.substring(1);
    }

    /**
     * Write generated class to file.
     */
    public void writeToFile(JavaFile javaFile) throws IOException {
        javaFile.writeTo(config.getOutputDirectory());
    }

    /**
     * Generate and write abstract class.
     */
    public Path generateAndWrite(MergedMessage message) throws IOException {
        JavaFile javaFile = generate(message);
        writeToFile(javaFile);

        String relativePath = (config.getApiPackage() + ".impl").replace('.', '/')
                + "/" + message.getAbstractClassName() + ".java";
        return config.getOutputDirectory().resolve(relativePath);
    }

    /**
     * Generate and write abstract class for a nested message (with flattened name).
     */
    public Path generateAndWriteNested(MergedMessage nested) throws IOException {
        JavaFile javaFile = generateNested(nested);
        writeToFile(javaFile);

        String relativePath = (config.getApiPackage() + ".impl").replace('.', '/')
                + "/" + nested.getFlattenedAbstractClassName() + ".java";
        return config.getOutputDirectory().resolve(relativePath);
    }

    /**
     * Generate abstract class for a nested message with flattened class name.
     */
    public JavaFile generateNested(MergedMessage nested) {
        String className = nested.getFlattenedAbstractClassName();
        String qualifiedInterfaceName = nested.getQualifiedInterfaceName();

        // Type parameter: PROTO extends Message
        TypeVariableName protoType = TypeVariableName.get("PROTO",
                ClassName.get("com.google.protobuf", "Message"));

        // Interface: ParentMessage.NestedMessage
        ClassName interfaceType = buildNestedClassName(qualifiedInterfaceName);

        TypeSpec.Builder classBuilder = TypeSpec.classBuilder(className)
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .addTypeVariable(protoType)
                .addSuperinterface(interfaceType)
                .addJavadoc("Abstract base class for $L implementations.\n\n", qualifiedInterfaceName)
                .addJavadoc("<p>Uses template method pattern - subclasses implement extract* methods.</p>\n")
                .addJavadoc("@param <PROTO> Protocol-specific message type\n");

        // Add protected field for convenient access
        classBuilder.addField(FieldSpec.builder(protoType, "proto", Modifier.PROTECTED, Modifier.FINAL)
                .addJavadoc("The underlying proto message.\n")
                .build());

        // Constructor
        classBuilder.addMethod(MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PROTECTED)
                .addParameter(protoType, "proto")
                .addStatement("this.proto = proto")
                .build());

        // Add abstract extract methods
        for (MergedField field : nested.getFieldsSorted()) {
            addExtractMethods(classBuilder, field, protoType, nested);
        }

        // Add concrete getter implementations
        for (MergedField field : nested.getFieldsSorted()) {
            addGetterImplementation(classBuilder, field, nested);
        }

        TypeSpec classSpec = classBuilder.build();

        return JavaFile.builder(config.getApiPackage() + ".impl", classSpec)
                .addFileComment("Generated by proto-wrapper-maven-plugin. DO NOT EDIT.")
                .indent("    ")
                .build();
    }
}
