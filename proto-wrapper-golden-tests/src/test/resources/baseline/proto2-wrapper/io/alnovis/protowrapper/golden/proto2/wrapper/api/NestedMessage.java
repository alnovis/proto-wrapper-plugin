// Generated by proto-wrapper-maven-plugin. DO NOT EDIT.
package io.alnovis.protowrapper.golden.proto2.wrapper.api;

import com.google.protobuf.InvalidProtocolBufferException;
import java.lang.Class;
import java.lang.String;
import java.util.List;

/**
 * Version-agnostic interface for NestedMessage.
 *
 * <p>Supported in versions: [v1, v2]</p>
 */
public interface NestedMessage extends ProtoWrapper {
    /**
     * @return id value
     */
    int getId();

    /**
     * Check if id is present.
     * @return true if the field has a value
     */
    boolean hasId();

    /**
     * @return name value
     */
    String getName();

    /**
     * Check if name is present.
     * @return true if the field has a value
     */
    boolean hasName();

    /**
     * Convert to a specific version implementation.
     * @param versionClass Target version class
     * @return Instance of the specified version
     */
    <T extends NestedMessage> T asVersion(Class<T> versionClass);

    /**
     * Convert to a specific version using VersionContext.
     * <p>This is a convenient alternative to {@link #asVersion(Class)} that allows
     * conversion without knowing the specific implementation class.</p>
     * @param targetContext VersionContext for the target version
     * @return Instance converted to the target version
     */
    NestedMessage asVersion(VersionContext targetContext);

    /**
     * Convert to a specific version by version identifier.
     * <p>This is a convenient alternative to {@link #asVersion(Class)} that allows
     * conversion using just the version ID string (e.g., "v202", "v203").</p>
     * @param targetVersionId Version identifier (e.g., "v202", "v203")
     * @return Instance converted to the target version
     * @throws IllegalArgumentException if targetVersionId is not supported
     */
    default NestedMessage asVersion(String targetVersionId) {
        return asVersion(VersionContext.forVersionId(targetVersionId));
    }

    /**
     * Convert to a specific version with strict data accessibility check.
     * <p>Unlike {@link #asVersion(Class)}, this method throws an exception if any
     * populated fields would become inaccessible in the target version.</p>
     * <p><b>Note:</b> Data is NOT physically lost (protobuf preserves unknown fields),
     * but it cannot be accessed through the target version's API.</p>
     * @param versionClass Target version class
     * @return Instance of the specified version
     * @throws IllegalStateException if any populated fields would become inaccessible
     */
    <T extends NestedMessage> T asVersionStrict(Class<T> versionClass);

    /**
     * Get the VersionContext for this wrapper's version.
     * <p>The context provides factory methods for creating other wrapper types
     * of the same protocol version.</p>
     * @return VersionContext for this version
     */
    VersionContext getContext();

    /**
     * Get fields that have values but will be inaccessible in the target version.
     * <p>These fields exist in the current version but not in the target version.
     * The data is NOT lost (protobuf preserves unknown fields), but it cannot be
     * accessed through the target version's API.</p>
     * @param targetVersion Target protocol version to check
     * @return List of field names that will become inaccessible
     */
    List<String> getFieldsInaccessibleInVersion(int targetVersion);

    /**
     * Check if conversion to target version will keep all data accessible.
     * <p>Returns true if no populated fields will become inaccessible.</p>
     * @param targetVersion Target protocol version to check
     * @return true if all populated fields will remain accessible
     */
    default boolean canConvertLosslesslyTo(int targetVersion) {
        return getFieldsInaccessibleInVersion(targetVersion).isEmpty();
    }

    /**
     * Create a new empty builder of the same version as this instance.
     * <p>Unlike {@link #toBuilder()}, this creates an empty builder without
     * copying any values from this instance.</p>
     * @return Empty builder for creating new instances
     */
    Builder emptyBuilder();

    /**
     * Create a builder initialized with this instance's values.
     * @return Builder for creating modified copies
     */
    Builder toBuilder();

    /**
     * Create a new builder for NestedMessage using the specified version context.
     * <p>This is a convenience method equivalent to {@code ctx.newNestedMessageBuilder()}.</p>
     * @param ctx Version context to use for builder creation
     * @return Empty builder for NestedMessage
     */
    static Builder newBuilder(VersionContext ctx) {
        return ctx.newNestedMessageBuilder();
    }

    /**
     * Parse bytes into a NestedMessage using the specified version context.
     * <p>This is a convenience method equivalent to {@code ctx.parseNestedMessageFromBytes(bytes)}.</p>
     * @param ctx Version context determining the protocol version
     * @param bytes Serialized protobuf data
     * @return Parsed NestedMessage instance
     * @throws InvalidProtocolBufferException if the bytes are not valid protobuf data
     */
    static NestedMessage parseFromBytes(VersionContext ctx, byte[] bytes) throws
            InvalidProtocolBufferException {
        return ctx.parseNestedMessageFromBytes(bytes);
    }

    /**
     * Parse bytes into a NestedMessage without checking required fields.
     *
     * <p>This method uses lenient parsing that does not validate proto2 required fields.
     * Use this when parsing messages that may have been serialized by a different
     * protocol version or when required fields validation should be skipped.</p>
     *
     * <p>This is a convenience method equivalent to {@code ctx.parsePartialNestedMessageFromBytes(bytes)}.</p>
     * @param ctx Version context determining the protocol version
     * @param bytes Serialized protobuf data
     * @return Parsed NestedMessage instance
     * @throws InvalidProtocolBufferException if the bytes are not valid protobuf data
     */
    static NestedMessage parsePartialFromBytes(VersionContext ctx, byte[] bytes) throws
            InvalidProtocolBufferException {
        return ctx.parsePartialNestedMessageFromBytes(bytes);
    }

    /**
     * Builder for creating and modifying NestedMessage instances.
     */
    interface Builder {
        /**
         * Set id value.
         */
        Builder setId(int id);

        /**
         * Clear id value.
         */
        Builder clearId();

        /**
         * Set name value.
         */
        Builder setName(String name);

        /**
         * Clear name value.
         */
        Builder clearName();

        /**
         * Build the NestedMessage instance.
         * @return New immutable instance
         */
        NestedMessage build();
    }
}
