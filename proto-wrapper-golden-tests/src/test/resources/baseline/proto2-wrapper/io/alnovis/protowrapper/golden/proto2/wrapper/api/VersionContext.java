// Generated by proto-wrapper-maven-plugin. DO NOT EDIT.
package io.alnovis.protowrapper.golden.proto2.wrapper.api;

import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.Message;
import io.alnovis.protowrapper.golden.proto2.wrapper.v1.VersionContextV1;
import io.alnovis.protowrapper.golden.proto2.wrapper.v2.VersionContextV2;
import io.alnovis.protowrapper.runtime.SchemaInfo;
import io.alnovis.protowrapper.runtime.VersionSchemaDiff;
import java.lang.IllegalArgumentException;
import java.lang.String;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Version context for creating version-specific wrapper instances.
 *
 * <p>Provides factory methods for obtaining version contexts and creating wrapper types.</p>
 *
 * <p>Usage:</p>
 * <pre>{@code
 * VersionContext ctx = VersionContext.forVersionId("v2");
 * Order order = ctx.wrapOrder(protoMessage);
 * }</pre>
 */
public interface VersionContext {
    Map<String, VersionContext> CONTEXTS = createContexts();

    List<String> SUPPORTED_VERSIONS = List.of(ProtocolVersions.V1, ProtocolVersions.V2);

    String DEFAULT_VERSION = ProtocolVersions.V2;

    private static Map<String, VersionContext> createContexts() {
        Map<String, VersionContext> map = new LinkedHashMap<>();
        map.put(ProtocolVersions.V1, VersionContextV1.INSTANCE);
        map.put(ProtocolVersions.V2, VersionContextV2.INSTANCE);
        return Collections.unmodifiableMap(map);
    }

    /**
     * Get VersionContext for a specific version identifier.
     *
     * @param versionId Version identifier (e.g., "v1", "v2")
     * @return VersionContext for the specified version
     * @throws IllegalArgumentException if versionId is null or not supported
     */
    static VersionContext forVersionId(String versionId) {
        VersionContext ctx = CONTEXTS.get(versionId);
        if (ctx == null) {
            throw new IllegalArgumentException("Unsupported version: '" + versionId + "'. Supported: " + SUPPORTED_VERSIONS);
        }
        return ctx;
    }

    /**
     * Find VersionContext for the specified version.
     *
     * @param versionId Version identifier (e.g., "v1", "v2")
     * @return Optional containing VersionContext, or empty if not supported
     */
    static Optional<VersionContext> find(String versionId) {
        return Optional.ofNullable(CONTEXTS.get(versionId));
    }

    /**
     * Get the default VersionContext (latest version).
     *
     * @return Default VersionContext (v2)
     */
    static VersionContext getDefault() {
        return CONTEXTS.get(DEFAULT_VERSION);
    }

    /**
     * Get list of supported version identifiers.
     *
     * @return Immutable list of supported versions (e.g., ["v1", "v2"])
     */
    static List<String> supportedVersions() {
        return SUPPORTED_VERSIONS;
    }

    /**
     * Get the default version identifier.
     *
     * @return Default version identifier ("v2")
     */
    static String defaultVersion() {
        return DEFAULT_VERSION;
    }

    /**
     * Check if a version is supported.
     *
     * @param versionId Version identifier to check
     * @return true if version is supported
     */
    static boolean isSupported(String versionId) {
        return CONTEXTS.containsKey(versionId);
    }

    /**
     * Get the version identifier for this context.
     *
     * @return Version identifier (e.g., "v1", "v2")
     */
    String getVersionId();

    /**
     * Wrap a proto NestedMessage message.
     * @param proto Proto message
     * @return Wrapped NestedMessage, or null if proto is null
     */
    NestedMessage wrapNestedMessage(Message proto);

    /**
     * Parse bytes and wrap as NestedMessage.
     * @param bytes Protobuf-encoded bytes
     * @return Wrapped NestedMessage, or null if bytes is null
     * @throws InvalidProtocolBufferException if bytes cannot be parsed
     */
    NestedMessage parseNestedMessageFromBytes(byte[] bytes) throws InvalidProtocolBufferException;

    /**
     * Parse bytes and wrap as NestedMessage without checking required fields.
     *
     * <p>This method uses lenient parsing that does not validate proto2 required fields.
     * Use this when parsing messages that may have been serialized by a different
     * protocol version or when required fields validation should be skipped.</p>
     *
     * @param bytes Protobuf-encoded bytes
     * @return Wrapped NestedMessage, or null if bytes is null
     * @throws InvalidProtocolBufferException if bytes cannot be parsed
     */
    NestedMessage parsePartialNestedMessageFromBytes(byte[] bytes) throws
            InvalidProtocolBufferException;

    /**
     * Wrap a proto AllFieldTypes message.
     * @param proto Proto message
     * @return Wrapped AllFieldTypes, or null if proto is null
     */
    AllFieldTypes wrapAllFieldTypes(Message proto);

    /**
     * Parse bytes and wrap as AllFieldTypes.
     * @param bytes Protobuf-encoded bytes
     * @return Wrapped AllFieldTypes, or null if bytes is null
     * @throws InvalidProtocolBufferException if bytes cannot be parsed
     */
    AllFieldTypes parseAllFieldTypesFromBytes(byte[] bytes) throws InvalidProtocolBufferException;

    /**
     * Parse bytes and wrap as AllFieldTypes without checking required fields.
     *
     * <p>This method uses lenient parsing that does not validate proto2 required fields.
     * Use this when parsing messages that may have been serialized by a different
     * protocol version or when required fields validation should be skipped.</p>
     *
     * @param bytes Protobuf-encoded bytes
     * @return Wrapped AllFieldTypes, or null if bytes is null
     * @throws InvalidProtocolBufferException if bytes cannot be parsed
     */
    AllFieldTypes parsePartialAllFieldTypesFromBytes(byte[] bytes) throws
            InvalidProtocolBufferException;

    /**
     * Create a new builder for NestedMessage.
     * @return Empty builder for NestedMessage
     */
    NestedMessage.Builder newNestedMessageBuilder();

    /**
     * Create a new builder for AllFieldTypes.
     * @return Empty builder for AllFieldTypes
     */
    AllFieldTypes.Builder newAllFieldTypesBuilder();

    /**
     * Get schema metadata for this version.
     *
     * <p>Provides runtime access to enum values and message field information.</p>
     *
     * <p>Example usage:</p>
     * <pre>{@code
     * SchemaInfo schema = ctx.getSchemaInfo();
     * schema.getEnum("TaxTypeEnum").ifPresent(e -> {
     *     for (SchemaInfo.EnumValue v : e.getValues()) {
     *         System.out.println(v.name() + " = " + v.number());
     *     }
     * });
     * }</pre>
     *
     * @return schema metadata for this version
     * @since 2.3.0
     */
    SchemaInfo getSchemaInfo();

    /**
     * Get schema diff from a previous version to this version.
     *
     * <p>Returns information about field and enum changes between versions,
     * including migration hints.</p>
     *
     * <p>Example usage:</p>
     * <pre>{@code
     * VersionContext ctx = VersionContext.forVersionId(ProtocolVersions.V203);
     * ctx.getDiffFrom(ProtocolVersions.V202).ifPresent(diff -> {
     *     diff.findFieldChange("Tax", "type").ifPresent(fc -> {
     *         System.out.println("Migration hint: " + fc.migrationHint());
     *     });
     * });
     * }</pre>
     *
     * @param previousVersion the version to diff from (e.g., "v202")
     * @return optional containing diff if available, empty if no diff exists
     * @since 2.3.0
     */
    Optional<VersionSchemaDiff> getDiffFrom(String previousVersion);
}
