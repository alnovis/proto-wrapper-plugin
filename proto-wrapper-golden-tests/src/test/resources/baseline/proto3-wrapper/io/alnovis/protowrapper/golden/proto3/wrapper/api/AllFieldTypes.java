// Generated by proto-wrapper-maven-plugin. DO NOT EDIT.
package io.alnovis.protowrapper.golden.proto3.wrapper.api;

import com.google.protobuf.InvalidProtocolBufferException;
import java.lang.Boolean;
import java.lang.Class;
import java.lang.Double;
import java.lang.Float;
import java.lang.Integer;
import java.lang.Long;
import java.lang.String;
import java.util.List;
import java.util.Map;

/**
 * Version-agnostic interface for AllFieldTypes.
 *
 * <p>Supported in versions: [v1, v2]</p>
 */
public interface AllFieldTypes extends ProtoWrapper {
    /**
     * @return singularInt32 value
     */
    Integer getSingularInt32();

    /**
     * @return singularInt64 value
     */
    Long getSingularInt64();

    /**
     * @return singularUint32 value
     */
    Integer getSingularUint32();

    /**
     * @return singularUint64 value
     */
    Long getSingularUint64();

    /**
     * @return singularSint32 value
     */
    Integer getSingularSint32();

    /**
     * @return singularSint64 value
     */
    Long getSingularSint64();

    /**
     * @return singularFixed32 value
     */
    Integer getSingularFixed32();

    /**
     * @return singularFixed64 value
     */
    Long getSingularFixed64();

    /**
     * @return singularSfixed32 value
     */
    Integer getSingularSfixed32();

    /**
     * @return singularSfixed64 value
     */
    Long getSingularSfixed64();

    /**
     * @return singularFloat value
     */
    Float getSingularFloat();

    /**
     * @return singularDouble value
     */
    Double getSingularDouble();

    /**
     * @return singularBool value
     */
    Boolean isSingularBool();

    /**
     * @return singularString value
     */
    String getSingularString();

    /**
     * @return singularBytes value
     */
    byte[] getSingularBytes();

    /**
     * @return singularMessage value
     */
    NestedMessage getSingularMessage();

    /**
     * Check if singularMessage is present.
     * @return true if the field has a value
     */
    boolean hasSingularMessage();

    /**
     * @return singularEnum value
     */
    TestEnum getSingularEnum();

    /**
     * @return optionalInt32 value
     */
    Integer getOptionalInt32();

    /**
     * Check if optionalInt32 is present.
     * @return true if the field has a value
     */
    boolean hasOptionalInt32();

    /**
     * @return optionalInt64 value
     */
    Long getOptionalInt64();

    /**
     * Check if optionalInt64 is present.
     * @return true if the field has a value
     */
    boolean hasOptionalInt64();

    /**
     * @return optionalUint32 value
     */
    Integer getOptionalUint32();

    /**
     * Check if optionalUint32 is present.
     * @return true if the field has a value
     */
    boolean hasOptionalUint32();

    /**
     * @return optionalUint64 value
     */
    Long getOptionalUint64();

    /**
     * Check if optionalUint64 is present.
     * @return true if the field has a value
     */
    boolean hasOptionalUint64();

    /**
     * @return optionalSint32 value
     */
    Integer getOptionalSint32();

    /**
     * Check if optionalSint32 is present.
     * @return true if the field has a value
     */
    boolean hasOptionalSint32();

    /**
     * @return optionalSint64 value
     */
    Long getOptionalSint64();

    /**
     * Check if optionalSint64 is present.
     * @return true if the field has a value
     */
    boolean hasOptionalSint64();

    /**
     * @return optionalFixed32 value
     */
    Integer getOptionalFixed32();

    /**
     * Check if optionalFixed32 is present.
     * @return true if the field has a value
     */
    boolean hasOptionalFixed32();

    /**
     * @return optionalFixed64 value
     */
    Long getOptionalFixed64();

    /**
     * Check if optionalFixed64 is present.
     * @return true if the field has a value
     */
    boolean hasOptionalFixed64();

    /**
     * @return optionalSfixed32 value
     */
    Integer getOptionalSfixed32();

    /**
     * Check if optionalSfixed32 is present.
     * @return true if the field has a value
     */
    boolean hasOptionalSfixed32();

    /**
     * @return optionalSfixed64 value
     */
    Long getOptionalSfixed64();

    /**
     * Check if optionalSfixed64 is present.
     * @return true if the field has a value
     */
    boolean hasOptionalSfixed64();

    /**
     * @return optionalFloat value
     */
    Float getOptionalFloat();

    /**
     * Check if optionalFloat is present.
     * @return true if the field has a value
     */
    boolean hasOptionalFloat();

    /**
     * @return optionalDouble value
     */
    Double getOptionalDouble();

    /**
     * Check if optionalDouble is present.
     * @return true if the field has a value
     */
    boolean hasOptionalDouble();

    /**
     * @return optionalBool value
     */
    Boolean isOptionalBool();

    /**
     * Check if optionalBool is present.
     * @return true if the field has a value
     */
    boolean hasOptionalBool();

    /**
     * @return optionalString value
     */
    String getOptionalString();

    /**
     * Check if optionalString is present.
     * @return true if the field has a value
     */
    boolean hasOptionalString();

    /**
     * @return optionalBytes value
     */
    byte[] getOptionalBytes();

    /**
     * Check if optionalBytes is present.
     * @return true if the field has a value
     */
    boolean hasOptionalBytes();

    /**
     * @return optionalMessage value
     */
    NestedMessage getOptionalMessage();

    /**
     * Check if optionalMessage is present.
     * @return true if the field has a value
     */
    boolean hasOptionalMessage();

    /**
     * @return optionalEnum value
     */
    TestEnum getOptionalEnum();

    /**
     * Check if optionalEnum is present.
     * @return true if the field has a value
     */
    boolean hasOptionalEnum();

    /**
     * @return repeatedInt32 value
     */
    List<Integer> getRepeatedInt32();

    /**
     * @return repeatedInt64 value
     */
    List<Long> getRepeatedInt64();

    /**
     * @return repeatedUint32 value
     */
    List<Integer> getRepeatedUint32();

    /**
     * @return repeatedUint64 value
     */
    List<Long> getRepeatedUint64();

    /**
     * @return repeatedSint32 value
     */
    List<Integer> getRepeatedSint32();

    /**
     * @return repeatedSint64 value
     */
    List<Long> getRepeatedSint64();

    /**
     * @return repeatedFixed32 value
     */
    List<Integer> getRepeatedFixed32();

    /**
     * @return repeatedFixed64 value
     */
    List<Long> getRepeatedFixed64();

    /**
     * @return repeatedSfixed32 value
     */
    List<Integer> getRepeatedSfixed32();

    /**
     * @return repeatedSfixed64 value
     */
    List<Long> getRepeatedSfixed64();

    /**
     * @return repeatedFloat value
     */
    List<Float> getRepeatedFloat();

    /**
     * @return repeatedDouble value
     */
    List<Double> getRepeatedDouble();

    /**
     * @return repeatedBool value
     */
    List<Boolean> getRepeatedBool();

    /**
     * @return repeatedString value
     */
    List<String> getRepeatedString();

    /**
     * @return repeatedBytes value
     */
    List<byte[]> getRepeatedBytes();

    /**
     * @return repeatedMessage value
     */
    List<NestedMessage> getRepeatedMessage();

    /**
     * @return repeatedEnum value
     */
    List<TestEnum> getRepeatedEnum();

    /**
     * @return oneofInt32 value
     */
    Integer getOneofInt32();

    /**
     * Check if oneofInt32 is present.
     * @return true if the field has a value
     */
    boolean hasOneofInt32();

    /**
     * @return oneofString value
     */
    String getOneofString();

    /**
     * Check if oneofString is present.
     * @return true if the field has a value
     */
    boolean hasOneofString();

    /**
     * @return oneofMessage value
     */
    NestedMessage getOneofMessage();

    /**
     * Check if oneofMessage is present.
     * @return true if the field has a value
     */
    boolean hasOneofMessage();

    /**
     * @return oneofEnum value
     */
    TestEnum getOneofEnum();

    /**
     * Check if oneofEnum is present.
     * @return true if the field has a value
     */
    boolean hasOneofEnum();

    /**
     * Get all entries in the stringToInt32 map.
     * @return unmodifiable map of String to int
     */
    Map<String, Integer> getStringToInt32Map();

    /**
     * Get the number of entries in the stringToInt32 map.
     * @return number of entries
     */
    int getStringToInt32Count();

    /**
     * Check if the stringToInt32 map contains the specified key.
     * @param key the key to check
     * @return true if the key exists
     */
    boolean containsStringToInt32(String key);

    /**
     * Get the value for the specified key, or a default value if not present.
     * @param key the key to look up
     * @param defaultValue the value to return if key is not present
     * @return the value for the key, or defaultValue if not present
     */
    int getStringToInt32OrDefault(String key, int defaultValue);

    /**
     * Get the value for the specified key, throwing if not present.
     * @param key the key to look up
     * @return the value for the key
     * @throws IllegalArgumentException if key is not present
     */
    int getStringToInt32OrThrow(String key);

    /**
     * Get all entries in the int32ToString map.
     * @return unmodifiable map of int to String
     */
    Map<Integer, String> getInt32ToStringMap();

    /**
     * Get the number of entries in the int32ToString map.
     * @return number of entries
     */
    int getInt32ToStringCount();

    /**
     * Check if the int32ToString map contains the specified key.
     * @param key the key to check
     * @return true if the key exists
     */
    boolean containsInt32ToString(int key);

    /**
     * Get the value for the specified key, or a default value if not present.
     * @param key the key to look up
     * @param defaultValue the value to return if key is not present
     * @return the value for the key, or defaultValue if not present
     */
    String getInt32ToStringOrDefault(int key, String defaultValue);

    /**
     * Get the value for the specified key, throwing if not present.
     * @param key the key to look up
     * @return the value for the key
     * @throws IllegalArgumentException if key is not present
     */
    String getInt32ToStringOrThrow(int key);

    /**
     * Get all entries in the stringToMessage map.
     * @return unmodifiable map of String to NestedMessage
     */
    Map<String, NestedMessage> getStringToMessageMap();

    /**
     * Get the number of entries in the stringToMessage map.
     * @return number of entries
     */
    int getStringToMessageCount();

    /**
     * Check if the stringToMessage map contains the specified key.
     * @param key the key to check
     * @return true if the key exists
     */
    boolean containsStringToMessage(String key);

    /**
     * Get the value for the specified key, or a default value if not present.
     * @param key the key to look up
     * @param defaultValue the value to return if key is not present
     * @return the value for the key, or defaultValue if not present
     */
    NestedMessage getStringToMessageOrDefault(String key, NestedMessage defaultValue);

    /**
     * Get the value for the specified key, throwing if not present.
     * @param key the key to look up
     * @return the value for the key
     * @throws IllegalArgumentException if key is not present
     */
    NestedMessage getStringToMessageOrThrow(String key);

    /**
     * Get all entries in the stringToEnum map.
     * @return unmodifiable map of String to TestEnum
     */
    Map<String, TestEnum> getStringToEnumMap();

    /**
     * Get the number of entries in the stringToEnum map.
     * @return number of entries
     */
    int getStringToEnumCount();

    /**
     * Check if the stringToEnum map contains the specified key.
     * @param key the key to check
     * @return true if the key exists
     */
    boolean containsStringToEnum(String key);

    /**
     * Get the value for the specified key, or a default value if not present.
     * @param key the key to look up
     * @param defaultValue the value to return if key is not present
     * @return the value for the key, or defaultValue if not present
     */
    TestEnum getStringToEnumOrDefault(String key, TestEnum defaultValue);

    /**
     * Get the value for the specified key, throwing if not present.
     * @param key the key to look up
     * @return the value for the key
     * @throws IllegalArgumentException if key is not present
     */
    TestEnum getStringToEnumOrThrow(String key);

    /**
     * Get all entries in the int64ToString map.
     * @return unmodifiable map of long to String
     */
    Map<Long, String> getInt64ToStringMap();

    /**
     * Get the number of entries in the int64ToString map.
     * @return number of entries
     */
    int getInt64ToStringCount();

    /**
     * Check if the int64ToString map contains the specified key.
     * @param key the key to check
     * @return true if the key exists
     */
    boolean containsInt64ToString(long key);

    /**
     * Get the value for the specified key, or a default value if not present.
     * @param key the key to look up
     * @param defaultValue the value to return if key is not present
     * @return the value for the key, or defaultValue if not present
     */
    String getInt64ToStringOrDefault(long key, String defaultValue);

    /**
     * Get the value for the specified key, throwing if not present.
     * @param key the key to look up
     * @return the value for the key
     * @throws IllegalArgumentException if key is not present
     */
    String getInt64ToStringOrThrow(long key);

    /**
     * Get which field in the 'test_oneof' oneof is currently set.
     * @return The case enum indicating which field is set, or TEST_ONEOF_NOT_SET if none
     */
    TestOneofCase getTestOneofCase();

    /**
     * Convert to a specific version implementation.
     * @param versionClass Target version class
     * @return Instance of the specified version
     */
    <T extends AllFieldTypes> T asVersion(Class<T> versionClass);

    /**
     * Convert to a specific version using VersionContext.
     * <p>This is a convenient alternative to {@link #asVersion(Class)} that allows
     * conversion without knowing the specific implementation class.</p>
     * @param targetContext VersionContext for the target version
     * @return Instance converted to the target version
     */
    AllFieldTypes asVersion(VersionContext targetContext);

    /**
     * Convert to a specific version by version identifier.
     * <p>This is a convenient alternative to {@link #asVersion(Class)} that allows
     * conversion using just the version ID string (e.g., "v202", "v203").</p>
     * @param targetVersionId Version identifier (e.g., "v202", "v203")
     * @return Instance converted to the target version
     * @throws IllegalArgumentException if targetVersionId is not supported
     */
    default AllFieldTypes asVersion(String targetVersionId) {
        return asVersion(VersionContext.forVersionId(targetVersionId));
    }

    /**
     * Convert to a specific version with strict data accessibility check.
     * <p>Unlike {@link #asVersion(Class)}, this method throws an exception if any
     * populated fields would become inaccessible in the target version.</p>
     * <p><b>Note:</b> Data is NOT physically lost (protobuf preserves unknown fields),
     * but it cannot be accessed through the target version's API.</p>
     * @param versionClass Target version class
     * @return Instance of the specified version
     * @throws IllegalStateException if any populated fields would become inaccessible
     */
    <T extends AllFieldTypes> T asVersionStrict(Class<T> versionClass);

    /**
     * Get the VersionContext for this wrapper's version.
     * <p>The context provides factory methods for creating other wrapper types
     * of the same protocol version.</p>
     * @return VersionContext for this version
     */
    VersionContext getContext();

    /**
     * Get fields that have values but will be inaccessible in the target version.
     * <p>These fields exist in the current version but not in the target version.
     * The data is NOT lost (protobuf preserves unknown fields), but it cannot be
     * accessed through the target version's API.</p>
     * @param targetVersion Target protocol version to check
     * @return List of field names that will become inaccessible
     */
    List<String> getFieldsInaccessibleInVersion(int targetVersion);

    /**
     * Check if conversion to target version will keep all data accessible.
     * <p>Returns true if no populated fields will become inaccessible.</p>
     * @param targetVersion Target protocol version to check
     * @return true if all populated fields will remain accessible
     */
    default boolean canConvertLosslesslyTo(int targetVersion) {
        return getFieldsInaccessibleInVersion(targetVersion).isEmpty();
    }

    /**
     * Create a new empty builder of the same version as this instance.
     * <p>Unlike {@link #toBuilder()}, this creates an empty builder without
     * copying any values from this instance.</p>
     * @return Empty builder for creating new instances
     */
    Builder emptyBuilder();

    /**
     * Create a builder initialized with this instance's values.
     * @return Builder for creating modified copies
     */
    Builder toBuilder();

    /**
     * Create a new builder for AllFieldTypes using the specified version context.
     * <p>This is a convenience method equivalent to {@code ctx.newAllFieldTypesBuilder()}.</p>
     * @param ctx Version context to use for builder creation
     * @return Empty builder for AllFieldTypes
     */
    static Builder newBuilder(VersionContext ctx) {
        return ctx.newAllFieldTypesBuilder();
    }

    /**
     * Parse bytes into a AllFieldTypes using the specified version context.
     * <p>This is a convenience method equivalent to {@code ctx.parseAllFieldTypesFromBytes(bytes)}.</p>
     * @param ctx Version context determining the protocol version
     * @param bytes Serialized protobuf data
     * @return Parsed AllFieldTypes instance
     * @throws InvalidProtocolBufferException if the bytes are not valid protobuf data
     */
    static AllFieldTypes parseFromBytes(VersionContext ctx, byte[] bytes) throws
            InvalidProtocolBufferException {
        return ctx.parseAllFieldTypesFromBytes(bytes);
    }

    /**
     * Parse bytes into a AllFieldTypes without checking required fields.
     *
     * <p>This method uses lenient parsing that does not validate proto2 required fields.
     * Use this when parsing messages that may have been serialized by a different
     * protocol version or when required fields validation should be skipped.</p>
     *
     * <p>This is a convenience method equivalent to {@code ctx.parsePartialAllFieldTypesFromBytes(bytes)}.</p>
     * @param ctx Version context determining the protocol version
     * @param bytes Serialized protobuf data
     * @return Parsed AllFieldTypes instance
     * @throws InvalidProtocolBufferException if the bytes are not valid protobuf data
     */
    static AllFieldTypes parsePartialFromBytes(VersionContext ctx, byte[] bytes) throws
            InvalidProtocolBufferException {
        return ctx.parsePartialAllFieldTypesFromBytes(bytes);
    }

    /**
     * Case enum for oneof 'test_oneof'.
     *
     * <p>Indicates which field in the oneof is currently set.</p>
     */
    enum TestOneofCase {
        ONEOF_INT32(60),

        ONEOF_STRING(61),

        ONEOF_MESSAGE(62),

        ONEOF_ENUM(63),

        TEST_ONEOF_NOT_SET(0);

        private final int number;

        TestOneofCase(int number) {
            this.number = number;
        }

        public int getNumber() {
            return number;
        }

        /**
         * Get the case constant for a field number.
         * @param number the proto field number
         * @return the corresponding case, or TEST_ONEOF_NOT_SET if not found
         */
        public static TestOneofCase forNumber(int number) {
            for (TestOneofCase c : values()) {
                if (c.number == number) {
                    return c;
                }
            }
            return TEST_ONEOF_NOT_SET;
        }
    }

    /**
     * Builder for creating and modifying AllFieldTypes instances.
     */
    interface Builder {
        /**
         * Set singularInt32 value.
         */
        Builder setSingularInt32(Integer singularInt32);

        /**
         * Set singularInt64 value.
         */
        Builder setSingularInt64(Long singularInt64);

        /**
         * Set singularUint32 value.
         */
        Builder setSingularUint32(Integer singularUint32);

        /**
         * Set singularUint64 value.
         */
        Builder setSingularUint64(Long singularUint64);

        /**
         * Set singularSint32 value.
         */
        Builder setSingularSint32(Integer singularSint32);

        /**
         * Set singularSint64 value.
         */
        Builder setSingularSint64(Long singularSint64);

        /**
         * Set singularFixed32 value.
         */
        Builder setSingularFixed32(Integer singularFixed32);

        /**
         * Set singularFixed64 value.
         */
        Builder setSingularFixed64(Long singularFixed64);

        /**
         * Set singularSfixed32 value.
         */
        Builder setSingularSfixed32(Integer singularSfixed32);

        /**
         * Set singularSfixed64 value.
         */
        Builder setSingularSfixed64(Long singularSfixed64);

        /**
         * Set singularFloat value.
         */
        Builder setSingularFloat(Float singularFloat);

        /**
         * Set singularDouble value.
         */
        Builder setSingularDouble(Double singularDouble);

        /**
         * Set singularBool value.
         */
        Builder setSingularBool(Boolean singularBool);

        /**
         * Set singularString value.
         */
        Builder setSingularString(String singularString);

        /**
         * Set singularBytes value.
         */
        Builder setSingularBytes(byte[] singularBytes);

        /**
         * Set singularMessage value.
         */
        Builder setSingularMessage(NestedMessage singularMessage);

        /**
         * Clear singularMessage value.
         */
        Builder clearSingularMessage();

        /**
         * Set singularEnum value.
         */
        Builder setSingularEnum(TestEnum singularEnum);

        /**
         * Set optionalInt32 value.
         */
        Builder setOptionalInt32(Integer optionalInt32);

        /**
         * Clear optionalInt32 value.
         */
        Builder clearOptionalInt32();

        /**
         * Set optionalInt64 value.
         */
        Builder setOptionalInt64(Long optionalInt64);

        /**
         * Clear optionalInt64 value.
         */
        Builder clearOptionalInt64();

        /**
         * Set optionalUint32 value.
         */
        Builder setOptionalUint32(Integer optionalUint32);

        /**
         * Clear optionalUint32 value.
         */
        Builder clearOptionalUint32();

        /**
         * Set optionalUint64 value.
         */
        Builder setOptionalUint64(Long optionalUint64);

        /**
         * Clear optionalUint64 value.
         */
        Builder clearOptionalUint64();

        /**
         * Set optionalSint32 value.
         */
        Builder setOptionalSint32(Integer optionalSint32);

        /**
         * Clear optionalSint32 value.
         */
        Builder clearOptionalSint32();

        /**
         * Set optionalSint64 value.
         */
        Builder setOptionalSint64(Long optionalSint64);

        /**
         * Clear optionalSint64 value.
         */
        Builder clearOptionalSint64();

        /**
         * Set optionalFixed32 value.
         */
        Builder setOptionalFixed32(Integer optionalFixed32);

        /**
         * Clear optionalFixed32 value.
         */
        Builder clearOptionalFixed32();

        /**
         * Set optionalFixed64 value.
         */
        Builder setOptionalFixed64(Long optionalFixed64);

        /**
         * Clear optionalFixed64 value.
         */
        Builder clearOptionalFixed64();

        /**
         * Set optionalSfixed32 value.
         */
        Builder setOptionalSfixed32(Integer optionalSfixed32);

        /**
         * Clear optionalSfixed32 value.
         */
        Builder clearOptionalSfixed32();

        /**
         * Set optionalSfixed64 value.
         */
        Builder setOptionalSfixed64(Long optionalSfixed64);

        /**
         * Clear optionalSfixed64 value.
         */
        Builder clearOptionalSfixed64();

        /**
         * Set optionalFloat value.
         */
        Builder setOptionalFloat(Float optionalFloat);

        /**
         * Clear optionalFloat value.
         */
        Builder clearOptionalFloat();

        /**
         * Set optionalDouble value.
         */
        Builder setOptionalDouble(Double optionalDouble);

        /**
         * Clear optionalDouble value.
         */
        Builder clearOptionalDouble();

        /**
         * Set optionalBool value.
         */
        Builder setOptionalBool(Boolean optionalBool);

        /**
         * Clear optionalBool value.
         */
        Builder clearOptionalBool();

        /**
         * Set optionalString value.
         */
        Builder setOptionalString(String optionalString);

        /**
         * Clear optionalString value.
         */
        Builder clearOptionalString();

        /**
         * Set optionalBytes value.
         */
        Builder setOptionalBytes(byte[] optionalBytes);

        /**
         * Clear optionalBytes value.
         */
        Builder clearOptionalBytes();

        /**
         * Set optionalMessage value.
         */
        Builder setOptionalMessage(NestedMessage optionalMessage);

        /**
         * Clear optionalMessage value.
         */
        Builder clearOptionalMessage();

        /**
         * Set optionalEnum value.
         */
        Builder setOptionalEnum(TestEnum optionalEnum);

        /**
         * Clear optionalEnum value.
         */
        Builder clearOptionalEnum();

        /**
         * Add a single repeatedInt32 element.
         */
        Builder addRepeatedInt32(Integer repeatedInt32);

        /**
         * Add all repeatedInt32 elements.
         */
        Builder addAllRepeatedInt32(List<Integer> repeatedInt32);

        /**
         * Replace all repeatedInt32 elements.
         */
        Builder setRepeatedInt32(List<Integer> repeatedInt32);

        /**
         * Clear all repeatedInt32 elements.
         */
        Builder clearRepeatedInt32();

        /**
         * Add a single repeatedInt64 element.
         */
        Builder addRepeatedInt64(Long repeatedInt64);

        /**
         * Add all repeatedInt64 elements.
         */
        Builder addAllRepeatedInt64(List<Long> repeatedInt64);

        /**
         * Replace all repeatedInt64 elements.
         */
        Builder setRepeatedInt64(List<Long> repeatedInt64);

        /**
         * Clear all repeatedInt64 elements.
         */
        Builder clearRepeatedInt64();

        /**
         * Add a single repeatedUint32 element.
         */
        Builder addRepeatedUint32(Integer repeatedUint32);

        /**
         * Add all repeatedUint32 elements.
         */
        Builder addAllRepeatedUint32(List<Integer> repeatedUint32);

        /**
         * Replace all repeatedUint32 elements.
         */
        Builder setRepeatedUint32(List<Integer> repeatedUint32);

        /**
         * Clear all repeatedUint32 elements.
         */
        Builder clearRepeatedUint32();

        /**
         * Add a single repeatedUint64 element.
         */
        Builder addRepeatedUint64(Long repeatedUint64);

        /**
         * Add all repeatedUint64 elements.
         */
        Builder addAllRepeatedUint64(List<Long> repeatedUint64);

        /**
         * Replace all repeatedUint64 elements.
         */
        Builder setRepeatedUint64(List<Long> repeatedUint64);

        /**
         * Clear all repeatedUint64 elements.
         */
        Builder clearRepeatedUint64();

        /**
         * Add a single repeatedSint32 element.
         */
        Builder addRepeatedSint32(Integer repeatedSint32);

        /**
         * Add all repeatedSint32 elements.
         */
        Builder addAllRepeatedSint32(List<Integer> repeatedSint32);

        /**
         * Replace all repeatedSint32 elements.
         */
        Builder setRepeatedSint32(List<Integer> repeatedSint32);

        /**
         * Clear all repeatedSint32 elements.
         */
        Builder clearRepeatedSint32();

        /**
         * Add a single repeatedSint64 element.
         */
        Builder addRepeatedSint64(Long repeatedSint64);

        /**
         * Add all repeatedSint64 elements.
         */
        Builder addAllRepeatedSint64(List<Long> repeatedSint64);

        /**
         * Replace all repeatedSint64 elements.
         */
        Builder setRepeatedSint64(List<Long> repeatedSint64);

        /**
         * Clear all repeatedSint64 elements.
         */
        Builder clearRepeatedSint64();

        /**
         * Add a single repeatedFixed32 element.
         */
        Builder addRepeatedFixed32(Integer repeatedFixed32);

        /**
         * Add all repeatedFixed32 elements.
         */
        Builder addAllRepeatedFixed32(List<Integer> repeatedFixed32);

        /**
         * Replace all repeatedFixed32 elements.
         */
        Builder setRepeatedFixed32(List<Integer> repeatedFixed32);

        /**
         * Clear all repeatedFixed32 elements.
         */
        Builder clearRepeatedFixed32();

        /**
         * Add a single repeatedFixed64 element.
         */
        Builder addRepeatedFixed64(Long repeatedFixed64);

        /**
         * Add all repeatedFixed64 elements.
         */
        Builder addAllRepeatedFixed64(List<Long> repeatedFixed64);

        /**
         * Replace all repeatedFixed64 elements.
         */
        Builder setRepeatedFixed64(List<Long> repeatedFixed64);

        /**
         * Clear all repeatedFixed64 elements.
         */
        Builder clearRepeatedFixed64();

        /**
         * Add a single repeatedSfixed32 element.
         */
        Builder addRepeatedSfixed32(Integer repeatedSfixed32);

        /**
         * Add all repeatedSfixed32 elements.
         */
        Builder addAllRepeatedSfixed32(List<Integer> repeatedSfixed32);

        /**
         * Replace all repeatedSfixed32 elements.
         */
        Builder setRepeatedSfixed32(List<Integer> repeatedSfixed32);

        /**
         * Clear all repeatedSfixed32 elements.
         */
        Builder clearRepeatedSfixed32();

        /**
         * Add a single repeatedSfixed64 element.
         */
        Builder addRepeatedSfixed64(Long repeatedSfixed64);

        /**
         * Add all repeatedSfixed64 elements.
         */
        Builder addAllRepeatedSfixed64(List<Long> repeatedSfixed64);

        /**
         * Replace all repeatedSfixed64 elements.
         */
        Builder setRepeatedSfixed64(List<Long> repeatedSfixed64);

        /**
         * Clear all repeatedSfixed64 elements.
         */
        Builder clearRepeatedSfixed64();

        /**
         * Add a single repeatedFloat element.
         */
        Builder addRepeatedFloat(Float repeatedFloat);

        /**
         * Add all repeatedFloat elements.
         */
        Builder addAllRepeatedFloat(List<Float> repeatedFloat);

        /**
         * Replace all repeatedFloat elements.
         */
        Builder setRepeatedFloat(List<Float> repeatedFloat);

        /**
         * Clear all repeatedFloat elements.
         */
        Builder clearRepeatedFloat();

        /**
         * Add a single repeatedDouble element.
         */
        Builder addRepeatedDouble(Double repeatedDouble);

        /**
         * Add all repeatedDouble elements.
         */
        Builder addAllRepeatedDouble(List<Double> repeatedDouble);

        /**
         * Replace all repeatedDouble elements.
         */
        Builder setRepeatedDouble(List<Double> repeatedDouble);

        /**
         * Clear all repeatedDouble elements.
         */
        Builder clearRepeatedDouble();

        /**
         * Add a single repeatedBool element.
         */
        Builder addRepeatedBool(Boolean repeatedBool);

        /**
         * Add all repeatedBool elements.
         */
        Builder addAllRepeatedBool(List<Boolean> repeatedBool);

        /**
         * Replace all repeatedBool elements.
         */
        Builder setRepeatedBool(List<Boolean> repeatedBool);

        /**
         * Clear all repeatedBool elements.
         */
        Builder clearRepeatedBool();

        /**
         * Add a single repeatedString element.
         */
        Builder addRepeatedString(String repeatedString);

        /**
         * Add all repeatedString elements.
         */
        Builder addAllRepeatedString(List<String> repeatedString);

        /**
         * Replace all repeatedString elements.
         */
        Builder setRepeatedString(List<String> repeatedString);

        /**
         * Clear all repeatedString elements.
         */
        Builder clearRepeatedString();

        /**
         * Add a single repeatedBytes element.
         */
        Builder addRepeatedBytes(byte[] repeatedBytes);

        /**
         * Add all repeatedBytes elements.
         */
        Builder addAllRepeatedBytes(List<byte[]> repeatedBytes);

        /**
         * Replace all repeatedBytes elements.
         */
        Builder setRepeatedBytes(List<byte[]> repeatedBytes);

        /**
         * Clear all repeatedBytes elements.
         */
        Builder clearRepeatedBytes();

        /**
         * Add a single repeatedMessage element.
         */
        Builder addRepeatedMessage(NestedMessage repeatedMessage);

        /**
         * Add all repeatedMessage elements.
         */
        Builder addAllRepeatedMessage(List<NestedMessage> repeatedMessage);

        /**
         * Replace all repeatedMessage elements.
         */
        Builder setRepeatedMessage(List<NestedMessage> repeatedMessage);

        /**
         * Clear all repeatedMessage elements.
         */
        Builder clearRepeatedMessage();

        /**
         * Add a single repeatedEnum element.
         */
        Builder addRepeatedEnum(TestEnum repeatedEnum);

        /**
         * Add all repeatedEnum elements.
         */
        Builder addAllRepeatedEnum(List<TestEnum> repeatedEnum);

        /**
         * Replace all repeatedEnum elements.
         */
        Builder setRepeatedEnum(List<TestEnum> repeatedEnum);

        /**
         * Clear all repeatedEnum elements.
         */
        Builder clearRepeatedEnum();

        /**
         * Set oneofInt32 value.
         */
        Builder setOneofInt32(Integer oneofInt32);

        /**
         * Clear oneofInt32 value.
         */
        Builder clearOneofInt32();

        /**
         * Set oneofString value.
         */
        Builder setOneofString(String oneofString);

        /**
         * Clear oneofString value.
         */
        Builder clearOneofString();

        /**
         * Set oneofMessage value.
         */
        Builder setOneofMessage(NestedMessage oneofMessage);

        /**
         * Clear oneofMessage value.
         */
        Builder clearOneofMessage();

        /**
         * Set oneofEnum value.
         */
        Builder setOneofEnum(TestEnum oneofEnum);

        /**
         * Clear oneofEnum value.
         */
        Builder clearOneofEnum();

        /**
         * Put a single entry into the stringToInt32 map.
         * @param key the key
         * @param value the value
         * @return this builder
         */
        Builder putStringToInt32(String key, int value);

        /**
         * Put all entries from the map into stringToInt32.
         * @param values the entries to add
         * @return this builder
         */
        Builder putAllStringToInt32(Map<String, Integer> values);

        /**
         * Remove an entry from the stringToInt32 map.
         * @param key the key to remove
         * @return this builder
         */
        Builder removeStringToInt32(String key);

        /**
         * Clear all entries from the stringToInt32 map.
         * @return this builder
         */
        Builder clearStringToInt32();

        /**
         * Get the current stringToInt32 map (for inspection during building).
         * @return unmodifiable view of the current map
         */
        Map<String, Integer> getStringToInt32Map();

        /**
         * Put a single entry into the int32ToString map.
         * @param key the key
         * @param value the value
         * @return this builder
         */
        Builder putInt32ToString(int key, String value);

        /**
         * Put all entries from the map into int32ToString.
         * @param values the entries to add
         * @return this builder
         */
        Builder putAllInt32ToString(Map<Integer, String> values);

        /**
         * Remove an entry from the int32ToString map.
         * @param key the key to remove
         * @return this builder
         */
        Builder removeInt32ToString(int key);

        /**
         * Clear all entries from the int32ToString map.
         * @return this builder
         */
        Builder clearInt32ToString();

        /**
         * Get the current int32ToString map (for inspection during building).
         * @return unmodifiable view of the current map
         */
        Map<Integer, String> getInt32ToStringMap();

        /**
         * Put a single entry into the stringToMessage map.
         * @param key the key
         * @param value the value
         * @return this builder
         */
        Builder putStringToMessage(String key, NestedMessage value);

        /**
         * Put all entries from the map into stringToMessage.
         * @param values the entries to add
         * @return this builder
         */
        Builder putAllStringToMessage(Map<String, NestedMessage> values);

        /**
         * Remove an entry from the stringToMessage map.
         * @param key the key to remove
         * @return this builder
         */
        Builder removeStringToMessage(String key);

        /**
         * Clear all entries from the stringToMessage map.
         * @return this builder
         */
        Builder clearStringToMessage();

        /**
         * Get the current stringToMessage map (for inspection during building).
         * @return unmodifiable view of the current map
         */
        Map<String, NestedMessage> getStringToMessageMap();

        /**
         * Put a single entry into the stringToEnum map.
         * @param key the key
         * @param value the value
         * @return this builder
         */
        Builder putStringToEnum(String key, TestEnum value);

        /**
         * Put all entries from the map into stringToEnum.
         * @param values the entries to add
         * @return this builder
         */
        Builder putAllStringToEnum(Map<String, TestEnum> values);

        /**
         * Remove an entry from the stringToEnum map.
         * @param key the key to remove
         * @return this builder
         */
        Builder removeStringToEnum(String key);

        /**
         * Clear all entries from the stringToEnum map.
         * @return this builder
         */
        Builder clearStringToEnum();

        /**
         * Get the current stringToEnum map (for inspection during building).
         * @return unmodifiable view of the current map
         */
        Map<String, TestEnum> getStringToEnumMap();

        /**
         * Put a single entry into the int64ToString map.
         * @param key the key
         * @param value the value
         * @return this builder
         */
        Builder putInt64ToString(long key, String value);

        /**
         * Put all entries from the map into int64ToString.
         * @param values the entries to add
         * @return this builder
         */
        Builder putAllInt64ToString(Map<Long, String> values);

        /**
         * Remove an entry from the int64ToString map.
         * @param key the key to remove
         * @return this builder
         */
        Builder removeInt64ToString(long key);

        /**
         * Clear all entries from the int64ToString map.
         * @return this builder
         */
        Builder clearInt64ToString();

        /**
         * Get the current int64ToString map (for inspection during building).
         * @return unmodifiable view of the current map
         */
        Map<Long, String> getInt64ToStringMap();

        /**
         * Clear the 'test_oneof' oneof - unsets whichever field is currently set.
         * @return This builder
         */
        Builder clearTestOneof();

        /**
         * Build the AllFieldTypes instance.
         * @return New immutable instance
         */
        AllFieldTypes build();
    }
}
