// Generated by proto-wrapper-maven-plugin. DO NOT EDIT.
package io.alnovis.protowrapper.golden.proto3.wrapper.api.impl;

import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.Message;
import io.alnovis.protowrapper.golden.proto3.wrapper.api.NestedMessage;
import io.alnovis.protowrapper.golden.proto3.wrapper.api.VersionContext;
import java.lang.Class;
import java.lang.Exception;
import java.lang.IllegalArgumentException;
import java.lang.IllegalStateException;
import java.lang.Integer;
import java.lang.NumberFormatException;
import java.lang.Object;
import java.lang.Override;
import java.lang.RuntimeException;
import java.lang.String;
import java.lang.Throwable;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Abstract base class for NestedMessage implementations.
 *
 * <p>Uses template method pattern - subclasses implement extract* methods.</p>
 * @param <PROTO> Protocol-specific message type
 */
public abstract class AbstractNestedMessage<PROTO extends Message> implements NestedMessage {
    /**
     * The underlying proto message.
     */
    protected final PROTO proto;

    protected AbstractNestedMessage(PROTO proto) {
        this.proto = proto;
    }

    protected abstract Integer extractId(PROTO proto);

    protected abstract String extractName(PROTO proto);

    @Override
    public final Integer getId() {
        return extractId(proto);
    }

    @Override
    public final String getName() {
        return extractName(proto);
    }

    /**
     * Get the underlying protobuf message.
     * @return protobuf Message
     */
    @Override
    public Message getTypedProto() {
        return proto;
    }

    protected abstract byte[] serializeToBytes(PROTO proto);

    @Override
    public final byte[] toBytes() {
        return serializeToBytes(proto);
    }

    protected abstract String extractWrapperVersionId(PROTO proto);

    @Override
    public final String getWrapperVersionId() {
        return extractWrapperVersionId(proto);
    }

    @Override
    public <T extends NestedMessage> T asVersion(Class<T> versionClass) {
        return convertToVersion(versionClass);
    }

    @Override
    public <T extends NestedMessage> T asVersionStrict(Class<T> versionClass) {
        if (versionClass.isInstance(this)) {
            return versionClass.cast(this);
        }
        int targetVersion = extractVersionFromPackage(versionClass.getPackage().getName());
        List<String> inaccessibleFields = getFieldsInaccessibleInVersion(targetVersion);
        if (!inaccessibleFields.isEmpty()) {
            throw new IllegalStateException(String.format("Cannot convert from version %s to version %d: the following fields have values but will become inaccessible in the target version: %s. Use asVersion() if you want to proceed anyway (data is preserved via protobuf unknown fields).", getWrapperVersionId(), targetVersion, inaccessibleFields));
        }
        return convertToVersion(versionClass);
    }

    @Override
    public NestedMessage asVersion(VersionContext targetContext) {
        if (targetContext.getVersionId().equals(getWrapperVersionId())) {
            return this;
        }
        try {
            return targetContext.parseNestedMessageFromBytes(this.toBytes());
        } catch (InvalidProtocolBufferException e) {
            throw new RuntimeException(String.format("Failed to convert %s from version %s to %s: %s", getClass().getSimpleName(), getWrapperVersionId(), targetContext.getVersionId(), e.getMessage()), e);
        }
    }

    /**
     * Convert to a specific version via serialization.
     * @param versionClass Target version class
     * @return Instance of the specified version
     */
    protected <T extends NestedMessage> T convertToVersion(Class<T> versionClass) {
        if (versionClass.isInstance(this)) {
            return versionClass.cast(this);
        }
        String targetVersionId = extractVersionIdFromPackage(versionClass.getPackage().getName());
        try {
            VersionContext targetContext = VersionContext.forVersionId(targetVersionId);
            byte[] bytes = this.toBytes();
            Method parseMethod = targetContext.getClass().getMethod("parseNestedMessageFromBytes", byte[].class);
            return versionClass.cast(parseMethod.invoke(targetContext, bytes));
        } catch (InvocationTargetException e) {
            Throwable cause = e.getCause() != null ? e.getCause() : e;
            throw new RuntimeException(String.format("Failed to convert %s from version %s to %s: %s - %s", getClass().getSimpleName(), getWrapperVersionId(), targetVersionId, cause.getClass().getSimpleName(), cause.getMessage()), cause);
        } catch (Exception e) {
            throw new RuntimeException(String.format("Failed to convert %s from version %s to %s: %s", getClass().getSimpleName(), getWrapperVersionId(), targetVersionId, e.getMessage()), e);
        }
    }

    private static String extractVersionIdFromPackage(String packageName) {
        int lastDot = packageName.lastIndexOf('.');
        if (lastDot > 0) {
            String lastSegment = packageName.substring(lastDot + 1);
            if (lastSegment.startsWith("v") && lastSegment.length() > 1) {
                return lastSegment;
            }
            int secondLastDot = packageName.lastIndexOf('.', lastDot - 1);
            if (secondLastDot > 0) {
                String secondLastSegment = packageName.substring(secondLastDot + 1, lastDot);
                if (secondLastSegment.startsWith("v") && secondLastSegment.length() > 1) {
                    return secondLastSegment;
                }
            }
        }
        throw new IllegalArgumentException("Cannot extract version from package: " + packageName);
    }

    private static int extractVersionFromPackage(String packageName) {
        String versionId = extractVersionIdFromPackage(packageName);
        String numStr = versionId.replaceAll("[^0-9]", "");
        try {
            return Integer.parseInt(numStr);
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("Cannot parse version number from: " + versionId);
        }
    }

    @Override
    public String toString() {
        return String.format("%s[version=%s] %s", getClass().getSimpleName(), getWrapperVersionId(), proto.toString().replace("\n", ", ").trim());
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        AbstractNestedMessage<?> other = (AbstractNestedMessage<?>) obj;
        return Objects.equals(this.getWrapperVersionId(), other.getWrapperVersionId()) && Objects.equals(this.proto, other.proto);
    }

    @Override
    public int hashCode() {
        return Objects.hash(getWrapperVersionId(), proto);
    }

    protected abstract VersionContext getVersionContext();

    @Override
    public final VersionContext getContext() {
        return getVersionContext();
    }

    @Override
    public List<String> getFieldsInaccessibleInVersion(int targetVersion) {
        List<String> inaccessible = new ArrayList<>();
        return inaccessible;
    }

    protected abstract NestedMessage.Builder createBuilder();

    @Override
    public final NestedMessage.Builder toBuilder() {
        return createBuilder();
    }

    protected abstract NestedMessage.Builder createEmptyBuilder();

    @Override
    public final NestedMessage.Builder emptyBuilder() {
        return createEmptyBuilder();
    }

    /**
     * Abstract builder base class.
     * @param <PROTO> Protocol-specific message type
     */
    public abstract static class AbstractBuilder<PROTO extends Message> implements NestedMessage.Builder {
        protected abstract void doSetId(Integer id);

        protected abstract void doSetName(String name);

        protected abstract NestedMessage doBuild();

        protected abstract String getVersionId();

        @Override
        public final NestedMessage.Builder setId(Integer id) {
            doSetId(id);
            return this;
        }

        @Override
        public final NestedMessage.Builder setName(String name) {
            doSetName(name);
            return this;
        }

        @Override
        public final NestedMessage build() {
            return doBuild();
        }
    }
}
