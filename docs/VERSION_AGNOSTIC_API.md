# Version-Agnostic API

[Russian version](VERSION_AGNOSTIC_API.ru.md)

A comprehensive guide to using the version-agnostic API generated by proto-wrapper-maven-plugin.

## Table of Contents

- [Overview](#overview)
- [Architecture](#architecture)
- [Read-Only Mode](#read-only-mode)
- [Builder Mode](#builder-mode)
- [VersionContext](#versioncontext)
- [Working with Nested Messages](#working-with-nested-messages)
- [Enum Handling](#enum-handling)
- [Serialization](#serialization)
- [Best Practices](#best-practices)

---

## Overview

The version-agnostic API provides a unified interface for working with multiple versions of protobuf messages. Instead of writing version-specific code, you work with common interfaces that abstract away the differences.

### Key Benefits

- **Single codebase**: Write business logic once, works with all versions
- **Type safety**: Compile-time checks prevent version mismatches
- **Automatic conversion**: Type conflicts are handled transparently
- **Extensibility**: Easy to add new versions without changing existing code

### Generated Components

| Component | Description |
|-----------|-------------|
| **Interfaces** | Version-agnostic API contracts (`api` package) |
| **Abstract Classes** | Common implementation logic (`api` package) |
| **Implementation Classes** | Version-specific implementations (`v1`, `v2` packages) |
| **VersionContext** | Factory for creating wrappers (`api` package) |
| **Enums** | Unified enumerations from all versions |

---

## Architecture

### Package Structure

```
com.example.model/
├── api/
│   ├── Order.java              (interface)
│   ├── AbstractOrder.java      (abstract class)
│   ├── OrderItem.java          (interface)
│   ├── AbstractOrderItem.java  (abstract class)
│   ├── PaymentType.java        (unified enum)
│   └── VersionContext.java     (factory)
├── v1/
│   ├── OrderV1.java            (implementation)
│   └── OrderItemV1.java        (implementation)
└── v2/
    ├── OrderV2.java            (implementation)
    └── OrderItemV2.java        (implementation)
```

### Class Hierarchy

```
                    <<interface>>
                       Order
                         │
                         ▼
                  AbstractOrder<P>
                    /         \
                   /           \
              OrderV1         OrderV2
         (proto: v1.Order)  (proto: v2.Order)
```

### Template Method Pattern

The abstract class uses the Template Method pattern, defining the algorithm skeleton while delegating version-specific extraction to subclasses:

```java
// AbstractOrder.java
public abstract class AbstractOrder<P extends Message> implements Order {
    protected final P proto;

    // Template method - same for all versions
    @Override
    public final String getCustomerId() {
        return hasCustomerId(proto) ? extractCustomerId(proto) : null;
    }

    // Abstract methods - implemented by version-specific classes
    protected abstract boolean hasCustomerId(P proto);
    protected abstract String extractCustomerId(P proto);
}
```

---

## Read-Only Mode

Read-only mode (default) generates wrappers without modification capabilities.

### Configuration

```xml
<configuration>
    <generateBuilders>false</generateBuilders>
</configuration>
```

### Generated Interface

```java
public interface Order {
    // Scalar fields
    String getOrderId();
    String getCustomerId();
    long getTotalAmount();

    // Optional fields with has-methods
    boolean hasShippingAddress();
    Address getShippingAddress();

    // Repeated fields
    List<OrderItem> getItems();

    // Enum fields
    PaymentType getPaymentType();

    // Serialization
    byte[] toBytes();
    Message getProto();
}
```

### Usage Example

```java
// Parse protobuf bytes
OrderProto proto = OrderProto.parseFrom(protoBytes);

// Wrap with version context
VersionContext ctx = VersionContext.forVersion(1);
Order order = ctx.wrapOrder(proto);

// Use unified API
String customerId = order.getCustomerId();
List<OrderItem> items = order.getItems();
PaymentType payment = order.getPaymentType();

// Nested messages are also wrapped
for (OrderItem item : items) {
    String productId = item.getProductId();
    int quantity = item.getQuantity();
    Money price = item.getPrice();
}

// Serialize back to bytes
byte[] outputBytes = order.toBytes();
```

### Direct Construction

You can also construct wrappers directly without VersionContext:

```java
// V1 wrapper
Order orderV1 = new OrderV1(v1Proto);

// V2 wrapper
Order orderV2 = new OrderV2(v2Proto);
```

---

## Builder Mode

Builder mode generates interfaces and implementations for creating and modifying protobuf messages.

### Configuration

```xml
<configuration>
    <generateBuilders>true</generateBuilders>
    <protobufMajorVersion>3</protobufMajorVersion>
</configuration>
```

### Generated Builder Interface

```java
public interface Order {
    // ... getter methods ...

    // Convert to builder
    Builder toBuilder();

    // Nested builder interface
    interface Builder {
        // Scalar setters
        Builder setOrderId(String value);
        Builder setCustomerId(String value);
        Builder setTotalAmount(long value);

        // Optional field setters
        Builder setShippingAddress(Address value);
        Builder clearShippingAddress();

        // Repeated field manipulation
        Builder addItem(OrderItem item);
        Builder addAllItems(List<OrderItem> items);
        Builder clearItems();

        // Enum setters
        Builder setPaymentType(PaymentType value);

        // Build the wrapper
        Order build();
    }
}
```

### Creating New Messages

```java
// Get builder from VersionContext
Order.Builder builder = VersionContext.forVersion(1).newOrderBuilder();

// Build the order
Order order = builder
    .setOrderId("ORD-001")
    .setCustomerId("CUST-123")
    .setTotalAmount(10000L)
    .setPaymentType(PaymentType.CREDIT_CARD)
    .build();

// Serialize
byte[] bytes = order.toBytes();
```

### Modifying Existing Messages

```java
// Wrap existing proto
Order order = ctx.wrapOrder(proto);

// Create modified copy
Order modified = order.toBuilder()
    .setTotalAmount(order.getTotalAmount() + 500L)
    .setPaymentType(PaymentType.BANK_TRANSFER)
    .build();
```

### Adding Nested Messages

```java
// Create nested message first
OrderItem.Builder itemBuilder = ctx.newOrderItemBuilder();
OrderItem item = itemBuilder
    .setProductId("PROD-001")
    .setQuantity(2)
    .setPrice(money)
    .build();

// Add to parent
Order order = ctx.newOrderBuilder()
    .setOrderId("ORD-001")
    .addItem(item)
    .build();
```

### Builder Implementation Details

The builder uses a similar Template Method pattern:

```java
// AbstractOrder$Builder.java
public abstract class AbstractOrder$Builder<P extends Message.Builder>
        implements Order.Builder {

    protected final P protoBuilder;

    @Override
    public final Order.Builder setCustomerId(String value) {
        doSetCustomerId(value);
        return this;
    }

    protected abstract void doSetCustomerId(String value);

    @Override
    public abstract Order build();
}
```

---

## VersionContext

VersionContext is a factory for creating version-specific wrappers and builders.

### Basic Usage

```java
// Get context for specific version
VersionContext ctx = VersionContext.forVersion(1);

// Or use constants
VersionContext v1 = VersionContext.V1;
VersionContext v2 = VersionContext.V2;
```

### Wrapping Methods

```java
// Wrap protobuf messages
Order order = ctx.wrapOrder(orderProto);
Customer customer = ctx.wrapCustomer(customerProto);
Product product = ctx.wrapProduct(productProto);
```

### Builder Methods (Builder Mode Only)

```java
// Create new builders
Order.Builder orderBuilder = ctx.newOrderBuilder();
Customer.Builder customerBuilder = ctx.newCustomerBuilder();
```

### Version Detection

```java
// Check wrapper version
if (order instanceof OrderV1) {
    // Handle V1-specific logic
}

// Or use getVersion() if available
int version = order.getVersion();
```

### Dynamic Version Selection

```java
public class OrderService {

    public Order processOrder(byte[] protoBytes, int apiVersion) {
        VersionContext ctx = VersionContext.forVersion(apiVersion);

        // Parse with correct proto class
        Message proto = parseProto(protoBytes, apiVersion);

        // Wrap with unified interface
        return ctx.wrapOrder(proto);
    }

    private Message parseProto(byte[] bytes, int version) {
        return switch (version) {
            case 1 -> com.example.proto.v1.OrderProto.parseFrom(bytes);
            case 2 -> com.example.proto.v2.OrderProto.parseFrom(bytes);
            default -> throw new IllegalArgumentException("Unknown version: " + version);
        };
    }
}
```

---

## Working with Nested Messages

Nested protobuf messages are automatically wrapped in their corresponding wrapper classes.

### Reading Nested Messages

```java
Order order = ctx.wrapOrder(proto);

// Single nested message
Address address = order.getShippingAddress();
if (address != null) {
    String street = address.getStreet();
    String city = address.getCity();
}

// Repeated nested messages
List<OrderItem> items = order.getItems();
for (OrderItem item : items) {
    Money price = item.getPrice();
    long amount = price.getAmount();
    String currency = price.getCurrency();
}
```

### Writing Nested Messages (Builder Mode)

```java
// Create nested message
Address.Builder addressBuilder = ctx.newAddressBuilder();
Address address = addressBuilder
    .setStreet("123 Main St")
    .setCity("New York")
    .setZipCode("10001")
    .build();

// Set in parent
Order order = ctx.newOrderBuilder()
    .setOrderId("ORD-001")
    .setShippingAddress(address)
    .build();
```

### Deeply Nested Structures

```java
// Access deeply nested fields
Order order = ctx.wrapOrder(proto);
Address shipping = order.getShippingAddress();
GeoLocation location = shipping.getLocation();
double latitude = location.getLatitude();
double longitude = location.getLongitude();
```

---

## Enum Handling

Enums are unified across versions into a single Java enum.

### Unified Enum Generation

When the same enum appears in multiple versions, the plugin merges them:

```protobuf
// v1/order.proto
enum PaymentType {
    UNKNOWN = 0;
    CASH = 1;
    CREDIT_CARD = 2;
}

// v2/order.proto
enum PaymentType {
    UNKNOWN = 0;
    CASH = 1;
    CREDIT_CARD = 2;
    BANK_TRANSFER = 3;  // New in v2
}
```

Generated unified enum:

```java
public enum PaymentType {
    UNKNOWN(0),
    CASH(1),
    CREDIT_CARD(2),
    BANK_TRANSFER(3);  // Included from v2

    private final int protoValue;

    public int getProtoValue() {
        return protoValue;
    }

    public static PaymentType fromProtoValue(int value) {
        // Returns matching enum or UNKNOWN
    }
}
```

### Using Enums

```java
// Reading
Order order = ctx.wrapOrder(proto);
PaymentType type = order.getPaymentType();

switch (type) {
    case CASH -> handleCashPayment(order);
    case CREDIT_CARD -> handleCardPayment(order);
    case BANK_TRANSFER -> handleBankTransfer(order);
    default -> handleUnknown(order);
}

// Writing (Builder mode)
Order modified = order.toBuilder()
    .setPaymentType(PaymentType.BANK_TRANSFER)
    .build();
```

### INT_ENUM Conflict

When a field is `int32` in one version and `enum` in another:

```java
public interface SensorReading {
    // Both accessors available
    int getUnitType();          // Raw int value
    UnitType getUnitTypeEnum(); // Unified enum

    interface Builder {
        Builder setUnitType(int value);
        Builder setUnitType(UnitType value);
    }
}
```

---

## Serialization

All wrappers support serialization back to protobuf bytes.

### Basic Serialization

```java
Order order = ctx.wrapOrder(proto);

// To bytes
byte[] bytes = order.toBytes();

// Access underlying proto
Message proto = order.getProto();
```

### Typed Proto Access

For version-specific operations, access the typed proto:

```java
OrderV1 orderV1 = (OrderV1) order;
com.example.proto.v1.OrderProto typedProto = orderV1.getTypedProto();

// Use proto-specific methods
typedProto.toBuilder()
    .setLegacyField("value")  // V1-only field
    .build();
```

### Cross-Version Serialization

```java
// V1 order
Order v1Order = VersionContext.V1.wrapOrder(v1Proto);
byte[] v1Bytes = v1Order.toBytes();

// Parse V1 bytes as V2 (if compatible)
com.example.proto.v2.OrderProto v2Proto =
    com.example.proto.v2.OrderProto.parseFrom(v1Bytes);
Order v2Order = VersionContext.V2.wrapOrder(v2Proto);
```

---

## Best Practices

### 1. Use VersionContext for Dynamic Versioning

```java
// Good: Dynamic version selection
public Order processOrder(byte[] bytes, int version) {
    VersionContext ctx = VersionContext.forVersion(version);
    return ctx.wrapOrder(parseProto(bytes, version));
}

// Avoid: Hard-coded version checks
public Order processOrder(byte[] bytes, int version) {
    if (version == 1) {
        return new OrderV1(V1OrderProto.parseFrom(bytes));
    } else {
        return new OrderV2(V2OrderProto.parseFrom(bytes));
    }
}
```

### 2. Program to Interfaces

```java
// Good: Use interface types
public void processOrder(Order order) {
    String customerId = order.getCustomerId();
    // Works with any version
}

// Avoid: Version-specific types
public void processOrder(OrderV1 order) {
    // Only works with V1
}
```

### 3. Handle Optional Fields Safely

```java
// Good: Check presence
if (order.hasShippingAddress()) {
    Address address = order.getShippingAddress();
    processAddress(address);
}

// Also good: Null check
Address address = order.getShippingAddress();
if (address != null) {
    processAddress(address);
}
```

### 4. Use Builder Pattern for Modifications

```java
// Good: Immutable modification
Order modified = order.toBuilder()
    .setStatus(OrderStatus.SHIPPED)
    .build();

// The original order is unchanged
assert order.getStatus() != OrderStatus.SHIPPED;
```

### 5. Handle Unknown Enum Values

```java
PaymentType type = order.getPaymentType();
if (type == null || type == PaymentType.UNKNOWN) {
    // Handle gracefully
    type = PaymentType.CASH;  // Default
}
```

### 6. Version-Specific Logic When Needed

```java
Order order = ctx.wrapOrder(proto);

// When you need version-specific behavior
if (order instanceof OrderV2 v2Order) {
    // Access V2-specific features
    String v2OnlyField = v2Order.getTypedProto().getV2OnlyField();
}
```

---

## See Also

- [COOKBOOK.md](COOKBOOK.md) - Practical usage guide with examples
- [KNOWN_ISSUES.md](KNOWN_ISSUES.md) - Known limitations and workarounds
- [README.md](../README.md) - Project overview and quick start

