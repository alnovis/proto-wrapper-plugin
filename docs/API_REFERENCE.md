# Proto Wrapper Generated Code API Reference

This document describes the structure and API of code generated by proto-wrapper plugin.

---

## Table of Contents

- [Overview](#overview)
- [Package Structure](#package-structure)
- [Generated Class Types](#generated-class-types)
  - [Interface](#interface)
  - [Abstract Class](#abstract-class)
  - [Implementation Class](#implementation-class)
  - [VersionContext](#versioncontext)
  - [Enum](#enum)
- [Generated Methods](#generated-methods)
  - [Field Accessors](#field-accessors)
  - [Version Information](#version-information)
  - [Serialization](#serialization)
  - [Version Conversion](#version-conversion)
  - [Builder Methods](#builder-methods)
- [Type Conflict Resolution](#type-conflict-resolution)
- [Repeated Fields with Type Conflicts](#repeated-fields-with-type-conflicts)
- [Well-Known Types](#well-known-types)
- [Map Fields](#map-fields)
- [Nested Types](#nested-types)
- [Oneof Fields](#oneof-fields)

---

## Overview

Proto-wrapper generates a layer of version-agnostic wrapper classes on top of protobuf-generated code. This allows application code to work with multiple protocol versions through a unified API.

### Design Goals

1. **Version Agnostic API** — Single interface works with all protocol versions
2. **Type Safety** — Compile-time type checking for all operations
3. **Immutability** — All wrapper instances are immutable and thread-safe
4. **Lossless Conversion** — Data is preserved when converting between versions
5. **Transparent Conflicts** — Type differences between versions are handled automatically

### Architecture Pattern

The generated code follows a **Template Method** pattern:

```
Interface (api)
    ↓
AbstractClass (api.impl) — shared logic via template methods
    ↓
Implementation (v1, v2, ...) — version-specific extraction
```

---

## Package Structure

Generated code is organized into the following packages:

| Package | Contents | Purpose |
|---------|----------|---------|
| `{basePackage}.api` | Interfaces, Enums, VersionContext | Version-agnostic public API |
| `{basePackage}.api.impl` | Abstract classes | Shared implementation logic |
| `{basePackage}.v1` | V1 implementations, VersionContextV1 | Version 1 specific code |
| `{basePackage}.v2` | V2 implementations, VersionContextV2 | Version 2 specific code |
| ... | Additional version packages | One package per protocol version |

---

## Generated Class Types

### Interface

**Location:** `{basePackage}.api`

**Purpose:** Defines the version-agnostic contract for a message type. Application code should depend only on these interfaces.

**Structure:**
```java
public interface {MessageName} {
    // Field accessors
    // Version information methods
    // Serialization methods
    // Version conversion methods
    // Builder access methods

    // Static factory method (v1.1.1+)
    static Builder newBuilder(VersionContext ctx);

    interface Builder { ... }  // Optional, when generateBuilders=true
}
```

**Key Characteristics:**
- Contains only method signatures, no implementation
- Declares all fields from all versions (union of fields)
- Fields not present in some versions return `null` or default values
- Nested message types are declared as nested interfaces

---

### Abstract Class

**Location:** `{basePackage}.api.impl`

**Purpose:** Implements shared logic using Template Method pattern. Concrete implementations only need to provide version-specific field extraction.

**Structure:**
```java
public abstract class Abstract{MessageName}<PROTO extends Message>
    implements {MessageName} {

    protected final PROTO proto;

    // Template methods (abstract) — implemented by subclasses
    protected abstract {Type} extract{Field}(PROTO proto);
    protected abstract boolean extractHas{Field}(PROTO proto);

    // Final implementations — delegate to template methods
    public final {Type} get{Field}() { ... }
    public final boolean has{Field}() { ... }

    // Common implementations
    public final String toString() { ... }
    public final boolean equals(Object obj) { ... }
    public final int hashCode() { ... }
}
```

**Key Characteristics:**
- Generic type parameter `PROTO` represents the version-specific protobuf class
- Holds immutable reference to underlying proto message
- All public methods are `final` to ensure consistent behavior
- `extract*` methods are the only version-specific code

---

### Implementation Class

**Location:** `{basePackage}.v1`, `{basePackage}.v2`, etc.

**Purpose:** Provides version-specific implementation by extracting values from the concrete protobuf message type.

**Structure:**
```java
public class {MessageName} extends Abstract{MessageName}<{Proto.MessageName}> {

    // Constructor
    public {MessageName}({Proto.MessageName} proto);

    // Static factory
    public static {MessageName} from({Proto.MessageName} proto);

    // Static builder factory (when generateBuilders=true)
    public static Builder newBuilder();

    // Typed proto access
    public {Proto.MessageName} getTypedProto();

    // Template method implementations
    @Override
    protected {Type} extract{Field}({Proto.MessageName} proto) { ... }
}
```

**Key Characteristics:**
- Extends abstract class with concrete proto type
- Implements all `extract*` template methods
- Provides typed access to underlying proto via `getTypedProto()`
- Contains nested `BuilderImpl` class when builders are enabled

---

### VersionContext

**Location:**
- Interface: `{basePackage}.api`
- Implementations: `{basePackage}.v1.VersionContextV1`, `{basePackage}.v2.VersionContextV2`, etc.

**Purpose:** Factory for creating wrapper instances of a specific protocol version. Provides a single entry point for all wrapper creation operations.

**Structure:**
```java
public interface VersionContext {
    // Static factory
    static VersionContext forVersion(int version);

    // Version info
    int getVersion();

    // For each message type:
    {MessageName} wrap{MessageName}(Message proto);
    {MessageName} parse{MessageName}FromBytes(byte[] bytes);
    {MessageName}.Builder new{MessageName}Builder();  // when generateBuilders=true

    // For nested types:
    {Parent}.{Nested}.Builder new{Parent}{Nested}Builder();
}
```

**Key Characteristics:**
- Singleton pattern — each version has one instance (`INSTANCE` field)
- Provides `wrap*` methods for wrapping existing proto messages
- Provides `parse*FromBytes` methods for deserializing from bytes
- Provides `new*Builder` methods for creating new instances
- Methods for types not present in a version throw `UnsupportedOperationException`

---

### Enum

**Location:** `{basePackage}.api`

**Purpose:** Unified enum type combining values from all protocol versions.

**Structure:**
```java
public enum {EnumName} {
    VALUE_ONE(0),
    VALUE_TWO(1),
    /** Present only in versions: [v2] */
    VALUE_THREE(2);  // Version-specific values are documented

    private final int value;

    {EnumName}(int value);

    public int getValue();
    public static {EnumName} fromProtoValue(int value);
}
```

**Conflict Enum** (generated for INT_ENUM conflicts):
```java
public enum {FieldName}Enum {
    // Same structure, but also includes:
    public static {EnumName} fromProtoValueOrDefault(int value, {EnumName} defaultValue);
    public static {EnumName} fromProtoValueOrThrow(int value);
}
```

---

## Generated Methods

### Field Accessors

#### get{Field}()

**Signature:** `{Type} get{Field}()`

**Purpose:** Returns the value of a message field.

**Behavior:**
- For required/singular fields: returns the value
- For optional fields not present: returns `null` (objects) or default (primitives)
- For repeated fields: returns unmodifiable `List<T>`, never `null`

---

#### has{Field}()

**Signature:** `boolean has{Field}()`

**Purpose:** Checks if an optional field has a value set.

**Generated for:** Optional fields only.

**Returns:** `true` if field has a value, `false` otherwise.

---

#### supports{Field}()

**Signature:** `default boolean supports{Field}()`

**Purpose:** Checks if this field exists in the current protocol version.

**Generated for:** Fields that exist only in some versions.

**Returns:** `true` if the current wrapper version supports this field.

**Use case:** Allows conditional logic based on field availability:
```java
if (wrapper.supportsNewField()) {
    // Safe to call getNewField()
}
```

---

### Version Information

#### getWrapperVersion()

**Signature:** `int getWrapperVersion()`

**Purpose:** Returns the protocol version number of this wrapper instance.

**Returns:** Version number (1, 2, 3, ...).

**Use case:** Runtime version detection for version-specific handling.

---

#### getContext()

**Signature:** `VersionContext getContext()`

**Purpose:** Returns the VersionContext for this wrapper's version.

**Use case:** Creating related objects of the same version:
```java
VersionContext ctx = order.getContext();
Money payment = ctx.newMoneyBuilder().setAmount(100).build();
```

---

### Serialization

#### toBytes()

**Signature:** `byte[] toBytes()`

**Purpose:** Serializes the wrapper to protobuf binary format.

**Returns:** Protobuf-encoded byte array.

**Use case:** Network transmission, storage, version conversion.

---

#### getTypedProto()

**Signature:** `{Proto.Type} getTypedProto()` (on implementation class only)

**Purpose:** Returns the underlying typed protobuf message.

**Use case:** Interoperability with code expecting raw proto objects.

---

### Version Conversion

#### asVersion(Class\<T\>)

**Signature:** `<T extends {Interface}> T asVersion(Class<T> versionClass)`

**Purpose:** Converts wrapper to a different version implementation.

**Mechanism:** Serializes to bytes, then deserializes with target version's parser.

**Data preservation:** All data is preserved via protobuf's unknown field handling. Fields not in target version become inaccessible through API but remain in the serialized form.

---

#### asVersionStrict(Class\<T\>)

**Signature:** `<T extends {Interface}> T asVersionStrict(Class<T> versionClass)`

**Purpose:** Strict conversion that fails if any populated fields would become inaccessible.

**Throws:** `IllegalStateException` if conversion would make fields inaccessible.

**Use case:** When data accessibility is critical and silent field inaccessibility is unacceptable.

---

#### getFieldsInaccessibleInVersion(int)

**Signature:** `List<String> getFieldsInaccessibleInVersion(int targetVersion)`

**Purpose:** Lists fields that have values but would become inaccessible in target version.

**Returns:** List of field names, empty if all fields remain accessible.

**Use case:** Pre-conversion validation, logging, user warnings.

---

#### canConvertLosslesslyTo(int)

**Signature:** `default boolean canConvertLosslesslyTo(int targetVersion)`

**Purpose:** Checks if conversion preserves accessibility of all populated fields.

**Returns:** `true` if `getFieldsInaccessibleInVersion(targetVersion).isEmpty()`.

---

### Builder Methods

Generated when `generateBuilders=true`.

#### newBuilder(VersionContext) — Static Factory

**Signature:** `static Builder newBuilder(VersionContext ctx)`

**Location:** On each interface (top-level and nested)

**Purpose:** Creates an empty builder using the specified version context.

**Parameters:**
- `ctx` — VersionContext determining the protocol version

**Returns:** Empty builder for creating new instances.

**Equivalence:** `Money.newBuilder(ctx)` is equivalent to `ctx.newMoneyBuilder()`.

**Use case:** More intuitive builder creation that mirrors the native protobuf pattern:
```java
// Native protobuf style
MyProto.MyMessage proto = MyProto.MyMessage.newBuilder()
        .setField("value")
        .build();

// Proto wrapper style (matches the pattern)
MyMessage wrapper = MyMessage.newBuilder(ctx)
        .setField("value")
        .build();
```

**Nested types:**
```java
// For nested interface Address.GeoLocation
Address.GeoLocation location = Address.GeoLocation.newBuilder(ctx)
        .setLatitude(40.7128)
        .setLongitude(-74.0060)
        .build();
```

---

#### toBuilder()

**Signature:** `Builder toBuilder()`

**Purpose:** Creates a builder initialized with current wrapper's values.

**Use case:** Creating modified copies of existing objects.

---

#### emptyBuilder()

**Signature:** `Builder emptyBuilder()`

**Purpose:** Creates an empty builder for the same version as this wrapper.

**Use case:** Creating new objects of the same version.

---

### Builder Interface Methods

#### set{Field}(value)

**Signature:** `Builder set{Field}({Type} value)`

**Purpose:** Sets the value of a field.

**Returns:** `this` for method chaining.

**Behavior for version-absent fields:** Throws `UnsupportedOperationException` with message indicating which versions support the field.

---

#### clear{Field}()

**Signature:** `Builder clear{Field}()`

**Purpose:** Clears an optional field to its default/unset state.

**Returns:** `this` for method chaining.

---

#### add{Field}(element) / addAll{Field}(list)

**Signature:** `Builder add{Field}({ElementType} element)`

**Purpose:** Adds element(s) to a repeated field.

**Generated for:** Repeated fields only.

---

#### build()

**Signature:** `{Interface} build()`

**Purpose:** Constructs the immutable wrapper instance.

**Returns:** New wrapper instance with builder's values.

---

## Type Conflict Resolution

When field types differ between protocol versions, the plugin generates unified accessors.

### INT_ENUM Conflict

**Condition:** Field is `int32` in some versions and `enum` in others.

**Generated methods:**

| Method | Returns | Purpose |
|--------|---------|---------|
| `get{Field}()` | `int` | Raw numeric value (works in all versions) |
| `get{Field}Enum()` | `{Field}Enum` | Type-safe enum value |

**Generated enum:** `{Field}Enum` with all enum values and `fromProtoValue()` converters.

---

### STRING_BYTES Conflict

**Condition:** Field is `string` in some versions and `bytes` in others.

**Generated methods:**

| Method | Returns | Purpose |
|--------|---------|---------|
| `get{Field}()` | `String` | String value (UTF-8 decoded for bytes) |
| `get{Field}Bytes()` | `byte[]` | Raw bytes (UTF-8 encoded for strings) |

---

### PRIMITIVE_MESSAGE Conflict

**Condition:** Field is primitive in some versions and message in others.

**Generated methods:**

| Method | Returns | Purpose |
|--------|---------|---------|
| `get{Field}()` | primitive type | Primitive value (0/default for message versions) |
| `get{Field}Message()` | message interface | Message value (null for primitive versions) |
| `supports{Field}()` | `boolean` | True if this version has primitive field |
| `supports{Field}Message()` | `boolean` | True if this version has message field |

---

### WIDENING Conflict

**Condition:** Field type widens between versions (e.g., `int32` → `int64`).

**Resolution:** Uses the wider type in the interface.

**Example:** `int32` in v1, `int64` in v2 → interface declares `long get{Field}()`.

---

## Repeated Fields with Type Conflicts

Since v1.4.0, proto-wrapper provides full builder support for repeated fields with type conflicts across versions.

### Supported Conflict Types

| Conflict | v1 Type | v2 Type | Unified Type | Range Validation |
|----------|---------|---------|--------------|------------------|
| **WIDENING** | `repeated int32` | `repeated int64` | `List<Long>` | Yes |
| **FLOAT_DOUBLE** | `repeated float` | `repeated double` | `List<Double>` | Yes |
| **SIGNED_UNSIGNED** | `repeated int32` | `repeated uint32` | `List<Long>` | Yes |
| **INT_ENUM** | `repeated int32` | `repeated SomeEnum` | `List<Integer>` | No |
| **STRING_BYTES** | `repeated string` | `repeated bytes` | `List<String>` | No |

### Generated Interface

```java
// Proto:
// v1: repeated int32 numbers = 1;
// v2: repeated int64 numbers = 1;

public interface RepeatedConflicts {
    // Getter - unified as wider type
    List<Long> getNumbers();

    interface Builder {
        // Add single element
        Builder addNumbers(long value);

        // Add multiple elements
        Builder addAllNumbers(List<Long> values);

        // Replace all elements
        Builder setNumbers(List<Long> values);

        // Clear all elements
        Builder clearNumbers();
    }
}
```

### Range Validation

When adding values to a version with a narrower type, runtime validation ensures values fit within the target type's range.

```java
// V1 builder (int32 range: -2,147,483,648 to 2,147,483,647):
wrapper.toBuilder()
    .addNumbers(100L)              // OK - within int32 range
    .addNumbers(2_147_483_647L)    // OK - max int32
    .addNumbers(9_999_999_999L)    // throws IllegalArgumentException
    .build();

// V2 builder (int64 range):
wrapper.toBuilder()
    .addNumbers(9_999_999_999L)    // OK - within int64 range
    .build();
```

**Error Messages:**

```
IllegalArgumentException: Value 9999999999 exceeds int32 range for v1
IllegalArgumentException: Value 1.0E309 exceeds float range for v1
IllegalArgumentException: Value -1 exceeds uint32 range for v2
```

### Usage Examples

#### Basic Usage

```java
VersionContext ctx = VersionContext.forVersion(2);

// Create new message
RepeatedConflicts message = RepeatedConflicts.newBuilder(ctx)
    .addNumbers(100L)
    .addNumbers(200L)
    .addNumbers(300L)
    .build();

assertThat(message.getNumbers()).containsExactly(100L, 200L, 300L);
```

#### Add Multiple Elements

```java
RepeatedConflicts modified = message.toBuilder()
    .addAllNumbers(List.of(400L, 500L))
    .build();

assertThat(modified.getNumbers()).containsExactly(100L, 200L, 300L, 400L, 500L);
```

#### Replace All Elements

```java
RepeatedConflicts replaced = message.toBuilder()
    .setNumbers(List.of(1L, 2L, 3L))
    .build();

assertThat(replaced.getNumbers()).containsExactly(1L, 2L, 3L);
```

#### Clear Elements

```java
RepeatedConflicts cleared = message.toBuilder()
    .clearNumbers()
    .build();

assertThat(cleared.getNumbers()).isEmpty();
```

### FLOAT_DOUBLE Conflict Example

```java
// v1: repeated float values = 1;
// v2: repeated double values = 2;

// Interface uses wider type (double)
List<Double> getValues();

// V1 builder validates float range
wrapper.toBuilder()
    .addValues(3.14)              // OK
    .addValues(Float.MAX_VALUE)   // OK
    .addValues(Double.MAX_VALUE)  // throws - exceeds float range
    .build();
```

### STRING_BYTES Conflict Example

```java
// v1: repeated string texts = 1;
// v2: repeated bytes texts = 2;

// Interface uses String with UTF-8 conversion
List<String> getTexts();

// Both versions accept String
wrapper.toBuilder()
    .addTexts("Hello")
    .addTexts("World")
    .addTexts("Unicode: \u4E2D\u6587")  // UTF-8 encoded for bytes version
    .build();
```

### INT_ENUM Conflict Example

```java
// v1: repeated int32 codes = 1;
// v2: repeated Status codes = 2;  // enum

// Interface uses Integer
List<Integer> getCodes();

// Use enum number values
wrapper.toBuilder()
    .addCodes(0)   // Status.UNKNOWN
    .addCodes(1)   // Status.ACTIVE
    .addCodes(2)   // Status.DELETED
    .build();
```

### Implementation Details

The generated code follows the Template Method pattern:

```java
// Abstract class
public abstract class AbstractRepeatedConflicts {
    public abstract static class AbstractBuilder {
        // Abstract methods for version-specific implementation
        protected abstract void doAddNumbers(long value);
        protected abstract void doAddAllNumbers(List<Long> values);
        protected abstract void doSetNumbers(List<Long> values);
        protected abstract void doClearNumbers();

        // Concrete public methods
        public final Builder addNumbers(long value) {
            doAddNumbers(value);
            return this;
        }
        // ... other methods
    }
}

// V1 Implementation with range validation
public class RepeatedConflicts extends AbstractRepeatedConflicts {
    private static class BuilderImpl extends AbstractBuilder {
        @Override
        protected void doAddNumbers(long value) {
            if (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE) {
                throw new IllegalArgumentException(
                    "Value " + value + " exceeds int32 range for v1");
            }
            protoBuilder.addNumbers((int) value);
        }
    }
}

// V2 Implementation (no validation needed for wider type)
public class RepeatedConflicts extends AbstractRepeatedConflicts {
    private static class BuilderImpl extends AbstractBuilder {
        @Override
        protected void doAddNumbers(long value) {
            protoBuilder.addNumbers(value);  // Direct assignment
        }
    }
}
```

---

## Well-Known Types

Since v1.3.0, proto-wrapper automatically converts Google Well-Known Types to idiomatic Java types.

### Supported Types

| Proto Type | Java Type | Notes |
|------------|-----------|-------|
| `google.protobuf.Timestamp` | `java.time.Instant` | Epoch-based time |
| `google.protobuf.Duration` | `java.time.Duration` | Time interval |
| `google.protobuf.StringValue` | `String` | Nullable string |
| `google.protobuf.Int32Value` | `Integer` | Nullable int |
| `google.protobuf.Int64Value` | `Long` | Nullable long |
| `google.protobuf.UInt32Value` | `Long` | Unsigned, nullable |
| `google.protobuf.UInt64Value` | `Long` | Unsigned, nullable |
| `google.protobuf.BoolValue` | `Boolean` | Nullable boolean |
| `google.protobuf.FloatValue` | `Float` | Nullable float |
| `google.protobuf.DoubleValue` | `Double` | Nullable double |
| `google.protobuf.BytesValue` | `byte[]` | Nullable bytes |
| `google.protobuf.FieldMask` | `List<String>` | Field paths |
| `google.protobuf.Struct` | `Map<String, Object>` | JSON-like |
| `google.protobuf.Value` | `Object` | Dynamic type |
| `google.protobuf.ListValue` | `List<Object>` | Dynamic list |

### Generated Interface Example

```java
// Proto definition:
// message Event {
//     google.protobuf.Timestamp created_at = 1;
//     google.protobuf.Duration timeout = 2;
//     google.protobuf.StringValue optional_name = 3;
//     google.protobuf.Struct metadata = 4;
// }

// Generated interface:
public interface Event {
    Instant getCreatedAt();         // java.time.Instant
    Duration getTimeout();           // java.time.Duration
    String getOptionalName();        // nullable String
    Map<String, Object> getMetadata(); // JSON-like structure

    boolean hasCreatedAt();
    boolean hasTimeout();
    boolean hasOptionalName();
    boolean hasMetadata();
}
```

### Temporal Types (Timestamp, Duration)

```java
Event event = ctx.wrapEvent(protoEvent);

// Get as Java types
Instant createdAt = event.getCreatedAt();
Duration timeout = event.getTimeout();

// Use Java Time API
LocalDateTime local = LocalDateTime.ofInstant(createdAt, ZoneId.systemDefault());
long seconds = timeout.getSeconds();
int nanos = timeout.getNano();
```

### Wrapper Types (Nullable Primitives)

```java
// These can distinguish "not set" from default value
String name = event.getOptionalName();  // null if not set
Integer count = event.getOptionalCount(); // null if not set

// Check if set
if (event.hasOptionalName()) {
    String name = event.getOptionalName();
}
```

### Struct/Value/ListValue (JSON-like)

```java
// Get as Java Map
Map<String, Object> metadata = event.getMetadata();

// Values can be: null, Double, String, Boolean, Map<String,Object>, List<Object>
String name = (String) metadata.get("name");
Double count = (Double) metadata.get("count");
Map<?, ?> nested = (Map<?, ?>) metadata.get("nested");
List<?> items = (List<?>) metadata.get("items");
```

### StructConverter Utility Class

When Struct/Value/ListValue fields are used, a utility class is auto-generated:

```java
// Generated in your API package
public final class StructConverter {
    public static Map<String, Object> toMap(Struct struct);
    public static Struct toStruct(Map<String, ?> map);
    public static Object toObject(Value value);
    public static Value toValue(Object obj);
    public static List<Object> toList(ListValue listValue);
    public static ListValue toListValue(List<?> list);
}
```

### Repeated Well-Known Types

```java
// Proto: repeated google.protobuf.Timestamp events = 1;
List<Instant> getEvents();  // List<java.time.Instant>

// Proto: repeated google.protobuf.StringValue optional_names = 2;
List<String> getOptionalNames();  // List<String>
```

### Builder Support

```java
Event event = Event.newBuilder(ctx)
    .setCreatedAt(Instant.now())
    .setTimeout(Duration.ofMinutes(5))
    .setOptionalName("test-event")
    .setMetadata(Map.of(
        "key1", "value1",
        "key2", 123.45,
        "nested", Map.of("a", "b")
    ))
    .build();
```

### Configuration

| Option | Default | Description |
|--------|---------|-------------|
| `convertWellKnownTypes` | `true` | Enable/disable WKT conversion |
| `generateRawProtoAccessors` | `false` | Generate `getXxxProto()` methods |

```xml
<configuration>
    <convertWellKnownTypes>true</convertWellKnownTypes>
    <generateRawProtoAccessors>false</generateRawProtoAccessors>
</configuration>
```

### Raw Proto Accessors

When `generateRawProtoAccessors=true`:

```java
public interface Event {
    // Converted accessor
    Instant getCreatedAt();

    // Raw proto accessor (additional)
    com.google.protobuf.Timestamp getCreatedAtProto();
}
```

### Not Supported: google.protobuf.Any

`Any` type requires a runtime type registry to unpack, which conflicts with the plugin's design principle of inline code with no runtime dependencies.

Workaround using raw accessor:

```java
// With generateRawProtoAccessors=true
Any any = message.getPayloadProto();
if (any.is(User.class)) {
    User user = any.unpack(User.class);
}
```

---

## Map Fields

Proto-wrapper provides full support for protobuf `map<K, V>` fields, including type conflict handling across versions.

### Generated Methods

For each map field, the following methods are generated:

| Method | Returns | Purpose |
|--------|---------|---------|
| `get{Field}Map()` | `Map<K, V>` | Returns unmodifiable map of all entries |
| `get{Field}Count()` | `int` | Returns number of entries |
| `contains{Field}(K key)` | `boolean` | Checks if key exists |
| `get{Field}OrDefault(K key, V default)` | `V` | Returns value or default if not present |
| `get{Field}OrThrow(K key)` | `V` | Returns value or throws if not present |

### Interface Example

```java
public interface MapTestMessage {
    // Map<String, Integer> field
    Map<String, Integer> getCountsMap();
    int getCountsCount();
    boolean containsCounts(String key);
    int getCountsOrDefault(String key, int defaultValue);
    int getCountsOrThrow(String key);

    // For version-specific maps
    boolean supportsCounts();  // Generated for fields not in all versions
}
```

### Builder Methods

```java
interface Builder {
    // Put single entry
    Builder putCounts(String key, int value);

    // Put all entries from map
    Builder putAllCounts(Map<String, Integer> values);

    // Remove entry by key
    Builder removeCounts(String key);

    // Clear all entries
    Builder clearCounts();

    // Get current map state (for inspection during building)
    Map<String, Integer> getCountsMap();
}
```

### Usage Example

```java
VersionContext ctx = VersionContext.forVersion(1);

// Create with map entries
MapTestMessage message = MapTestMessage.newBuilder(ctx)
        .putCounts("apple", 5)
        .putCounts("banana", 3)
        .putAllCounts(Map.of("cherry", 10, "date", 7))
        .build();

// Read map data
Map<String, Integer> counts = message.getCountsMap();
int appleCount = message.getCountsOrDefault("apple", 0);  // 5
boolean hasGrape = message.containsCounts("grape");        // false

// Iterate
for (Map.Entry<String, Integer> entry : counts.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
```

### Map Type Conflicts

When map value types differ between versions, the plugin automatically handles conversion.

#### WIDENING Map Conflict

**Condition:** Map value type widens (e.g., `map<string, int32>` → `map<string, int64>`).

**Resolution:** Uses wider type in interface, automatic conversion in implementations.

```java
// v1: map<string, int32> counts = 1;
// v2: map<string, int64> counts = 1;

public interface Message {
    Map<String, Long> getCountsMap();  // Unified as Long
}
```

**Implementation behavior:**
- V1: Converts `int` values to `long` on read
- V2: Returns `long` values directly
- Builder validates range when setting values for V1

#### INT_ENUM Map Conflict

**Condition:** Map value is `int32` in some versions and `enum` in others.

**Resolution:** Uses `int` as unified type, with automatic enum conversion.

```java
// v1: map<string, int32> status_map = 1;
// v2: map<string, Status> status_map = 1;  // Status enum

public interface Message {
    Map<String, Integer> getStatusMapMap();  // Unified as Integer
}
```

**Implementation behavior:**
- V1: Returns `int` values directly
- V2: Converts enum to `int` using `getNumber()` (NOT `ordinal()`)
- Builder validates enum values when setting for V2

**Important:** For non-sequential enum values (e.g., `UNKNOWN=0, ACTIVE=10, DELETED=20`), the correct proto number is preserved. Using `ordinal()` would incorrectly return 0, 1, 2.

### Performance Optimization: Lazy Caching

For maps requiring type conversion (WIDENING, INT_ENUM), the generated code uses lazy caching with `volatile` fields for thread-safe performance:

```java
// Generated implementation (simplified)
private volatile Map<String, Long> cachedWideningCountsMap;

@Override
protected Map<String, Long> extractWideningCountsMap(Proto proto) {
    if (cachedWideningCountsMap != null) {
        return cachedWideningCountsMap;
    }
    // Convert and cache
    Map<String, Integer> source = proto.getWideningCountsMap();
    Map<String, Long> result = new LinkedHashMap<>(source.size());
    source.forEach((k, v) -> result.put(k, v.longValue()));
    cachedWideningCountsMap = result;
    return result;
}
```

**Benefits:**
- First access computes and caches the converted map
- Subsequent accesses return cached value immediately
- Thread-safe via `volatile` field
- Immutable wrapper ensures cache validity

### Builder Validation

The builder validates enum values when putting entries for versions that use enum types:

```java
MapConflictMessage.Builder builder = MapConflictMessage.newBuilder(ctx);

// Valid enum values
builder.putStatusMap("key1", 0);   // OK - UNKNOWN
builder.putStatusMap("key2", 1);   // OK - ACTIVE

// Invalid enum value
builder.putStatusMap("key3", 999); // Throws IllegalArgumentException
// Message: "Invalid enum value 999 for field 'status_map'"
```

### Version-Specific Maps

Maps that exist only in some versions:

```java
// scores map only in V2
if (message.supportsScores()) {
    Map<String, Double> scores = message.getScoresMap();
}

// In V1, getScoresMap() returns empty map
```

### Cross-Version Conversion

Map data is preserved during version conversion:

```java
// V1 wrapper with map data
MapTestMessage v1 = ctx1.newMapTestMessageBuilder()
        .putCounts("key", 100)
        .build();

// Convert to V2
MapTestMessage v2 = v1.asVersion(space.example.v2.MapTestMessage.class);

// Data preserved
assertEquals(100, v2.getCountsOrThrow("key"));
```

---

## Nested Types

Nested protobuf messages are generated as nested interfaces/classes.

**Structure:**
```java
public interface {Parent} {

    interface {Nested} {
        // Field accessors

        // Static factory method (v1.1.1+)
        static Builder newBuilder(VersionContext ctx);

        interface Builder { ... }
    }

    {Nested} get{Nested}();
    boolean has{Nested}();
}
```

**Creating nested type instances:**

```java
// Using static newBuilder (recommended, v1.1.1+)
Address.GeoLocation location = Address.GeoLocation.newBuilder(ctx)
        .setLatitude(40.7128)
        .setLongitude(-74.0060)
        .build();

// Using VersionContext method (still works)
Address.GeoLocation location = ctx.newAddressGeoLocationBuilder()
        .setLatitude(40.7128)
        .setLongitude(-74.0060)
        .build();
```

**VersionContext methods for nested types:**
```java
{Parent}.{Nested}.Builder new{Parent}{Nested}Builder();
```

**Deep nesting:** Supported to arbitrary depth:
- Static method: `Parent.Child.GrandChild.newBuilder(ctx)`
- Context method: `ctx.newParentChildGrandChildBuilder()`

---

## Oneof Fields

Proto-wrapper provides full support for protobuf `oneof` fields, generating type-safe discriminator enums and appropriate accessor methods.

### Case Enum

For each oneof group, a nested Case enum is generated:

```java
public interface Payment {
    // Case enum for oneof 'method'
    enum MethodCase {
        CREDIT_CARD(10),
        BANK_TRANSFER(11),
        CRYPTO(12),           // V2 only
        METHOD_NOT_SET(0);

        private final int number;

        MethodCase(int number) { this.number = number; }
        public int getNumber() { return number; }

        public static MethodCase forNumber(int number) {
            for (MethodCase c : values()) {
                if (c.number == number) return c;
            }
            return METHOD_NOT_SET;
        }
    }

    // Discriminator method
    MethodCase getMethodCase();

    // Individual field checks
    boolean hasCreditCard();
    boolean hasBankTransfer();
    boolean hasCrypto();

    // Field accessors
    CreditCard getCreditCard();
    BankTransfer getBankTransfer();
    Crypto getCrypto();
}
```

### Usage Example

```java
VersionContext ctx = VersionContext.forVersion(1);

// Create with credit card
CreditCard card = ctx.newCreditCardBuilder()
        .setCardNumber("4111111111111111")
        .setExpiry("12/25")
        .build();

Payment payment = ctx.newPaymentBuilder()
        .setId("PAY-001")
        .setAmount(10000L)
        .setCreditCard(card)
        .build();

// Check which field is set
switch (payment.getMethodCase()) {
    case CREDIT_CARD -> handleCard(payment.getCreditCard());
    case BANK_TRANSFER -> handleTransfer(payment.getBankTransfer());
    case CRYPTO -> handleCrypto(payment.getCrypto());
    case METHOD_NOT_SET -> handleNoMethod();
}
```

### Builder Methods

```java
Payment.Builder builder = ctx.newPaymentBuilder()
        .setId("PAY-001")
        .setAmount(10000L);

// Set oneof field (replaces any previously set field)
builder.setCreditCard(card);
builder.setBankTransfer(transfer);  // Replaces credit card

// Clear oneof group
builder.clearMethod();  // All oneof fields become unset

Payment payment = builder.build();
```

### Version Differences

When oneof options differ between versions:

- **V1 has 2 options:** CREDIT_CARD, BANK_TRANSFER
- **V2 has 3 options:** CREDIT_CARD, BANK_TRANSFER, CRYPTO

The merged interface/enum includes all options from all versions. When converting:

- **V1 -> V2:** Works seamlessly, V1 fields are preserved
- **V2 -> V1 with CRYPTO:** Field is silently dropped (V1 doesn't support it)

---

### Oneof Conflict Detection

The plugin automatically detects and logs conflicts related to oneof fields across versions. Conflicts are logged at WARN level during code generation.

#### Conflict Types

| Conflict Type | Description | Example |
|--------------|-------------|---------|
| `PARTIAL_EXISTENCE` | Oneof exists only in some versions | V1: no oneof, V2: has oneof "method" |
| `FIELD_SET_DIFFERENCE` | Different fields in oneof across versions | V1: {credit_card, bank_transfer}, V2: adds {crypto} |
| `FIELD_TYPE_CONFLICT` | Type conflict within oneof field | V1: string text=1, V2: bytes text=1 |
| `RENAMED` | Oneof renamed between versions | V1: "payment_method", V2: "method" (same fields) |
| `FIELD_MEMBERSHIP_CHANGE` | Field moved in/out of oneof | V1: regular field, V2: inside oneof |
| `FIELD_NUMBER_CHANGE` | Field number changed | V1: credit_card=10, V2: credit_card=15 |
| `FIELD_REMOVED` | Field removed from oneof | V1: {credit_card, cash}, V2: {credit_card} only |
| `INCOMPATIBLE_TYPES` | Incompatible field types in oneof | Cannot be safely merged |

#### Renamed Oneof Detection

The plugin detects renamed oneofs by comparing field number sets:

```protobuf
// V1
message Payment {
    oneof payment_method {
        CreditCard credit_card = 10;
        BankTransfer bank_transfer = 11;
    }
}

// V2 - same fields, different oneof name
message Payment {
    oneof method {
        CreditCard credit_card = 10;
        BankTransfer bank_transfer = 11;
    }
}
```

When detected, the plugin:
1. Merges both oneofs into a single `MergedOneof`
2. Uses the most common name across versions
3. Logs a warning: `Oneof RENAMED: 'Payment.method' has different names: {v1=payment_method, v2=method}`

#### Field Membership Changes

Detects when a field moves in or out of a oneof:

```protobuf
// V1 - regular field
message Payment {
    CreditCard credit_card = 10;
}

// V2 - now inside oneof
message Payment {
    oneof method {
        CreditCard credit_card = 10;
        BankTransfer bank_transfer = 11;
    }
}
```

Warning: `Oneof MEMBERSHIP: 'Payment' - Field 'credit_card' (#10) moved into oneof in versions: [v2]`

#### Example Log Output

```
[WARN] Oneof PARTIAL: 'Payment.method' not in all versions - Missing in: [v1]
[WARN] Oneof FIELD_DIFF: 'Payment.method' - Field #12 present only in: [v2]
[WARN] Oneof RENAMED: 'Payment.method' has different names: {v1=payment_method, v2=method}
[WARN] Oneof MEMBERSHIP: 'Payment' - Field 'credit_card' (#10) moved into oneof
```

#### Accessing Conflict Information Programmatically

The `MergedOneof` class provides methods to query detected conflicts:

```java
MergedOneof oneof = mergedMessage.findOneofByName("method").orElseThrow();

// Check for conflicts
if (oneof.hasConflicts()) {
    List<OneofConflictInfo> conflicts = oneof.getConflicts();

    for (OneofConflictInfo conflict : conflicts) {
        System.out.println("Type: " + conflict.getType());
        System.out.println("Description: " + conflict.getDescription());
        System.out.println("Affected versions: " + conflict.getAffectedVersions());
    }
}

// Check for specific conflict type
if (oneof.hasConflictOfType(OneofConflictType.RENAMED)) {
    Set<String> names = oneof.getMergedFromNames();
    System.out.println("Oneof was renamed, original names: " + names);
}

// Check if oneof exists in all versions
Set<String> allVersions = Set.of("v1", "v2", "v3");
if (!oneof.isUniversal(allVersions)) {
    Set<String> missing = oneof.getMissingVersions(allVersions);
    System.out.println("Oneof missing in: " + missing);
}
```

---

## Thread Safety

- **Wrapper instances:** Immutable, thread-safe
- **Builder instances:** NOT thread-safe, use separate builder per thread
- **VersionContext:** Thread-safe singleton

---

## See Also

- [COOKBOOK.md](COOKBOOK.md) — Practical usage examples
- [KNOWN_ISSUES.md](KNOWN_ISSUES.md) — Limitations and workarounds
- [VERSION_AGNOSTIC_API.md](VERSION_AGNOSTIC_API.md) — Design philosophy
