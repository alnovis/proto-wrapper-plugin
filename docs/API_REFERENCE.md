# Proto Wrapper Generated Code API Reference

This document describes the structure and API of code generated by proto-wrapper plugin.

---

## Table of Contents

- [Overview](#overview)
- [Package Structure](#package-structure)
- [Generated Class Types](#generated-class-types)
  - [Interface](#interface)
  - [Abstract Class](#abstract-class)
  - [Implementation Class](#implementation-class)
  - [VersionContext](#versioncontext)
  - [Enum](#enum)
- [Generated Methods](#generated-methods)
  - [Field Accessors](#field-accessors)
  - [Version Information](#version-information)
  - [Serialization](#serialization)
  - [Version Conversion](#version-conversion)
  - [Builder Methods](#builder-methods)
- [Type Conflict Resolution](#type-conflict-resolution)
- [Nested Types](#nested-types)
- [Oneof Fields](#oneof-fields)

---

## Overview

Proto-wrapper generates a layer of version-agnostic wrapper classes on top of protobuf-generated code. This allows application code to work with multiple protocol versions through a unified API.

### Design Goals

1. **Version Agnostic API** — Single interface works with all protocol versions
2. **Type Safety** — Compile-time type checking for all operations
3. **Immutability** — All wrapper instances are immutable and thread-safe
4. **Lossless Conversion** — Data is preserved when converting between versions
5. **Transparent Conflicts** — Type differences between versions are handled automatically

### Architecture Pattern

The generated code follows a **Template Method** pattern:

```
Interface (api)
    ↓
AbstractClass (api.impl) — shared logic via template methods
    ↓
Implementation (v1, v2, ...) — version-specific extraction
```

---

## Package Structure

Generated code is organized into the following packages:

| Package | Contents | Purpose |
|---------|----------|---------|
| `{basePackage}.api` | Interfaces, Enums, VersionContext | Version-agnostic public API |
| `{basePackage}.api.impl` | Abstract classes | Shared implementation logic |
| `{basePackage}.v1` | V1 implementations, VersionContextV1 | Version 1 specific code |
| `{basePackage}.v2` | V2 implementations, VersionContextV2 | Version 2 specific code |
| ... | Additional version packages | One package per protocol version |

---

## Generated Class Types

### Interface

**Location:** `{basePackage}.api`

**Purpose:** Defines the version-agnostic contract for a message type. Application code should depend only on these interfaces.

**Structure:**
```java
public interface {MessageName} {
    // Field accessors
    // Version information methods
    // Serialization methods
    // Version conversion methods
    // Builder access methods

    // Static factory method (v1.1.1+)
    static Builder newBuilder(VersionContext ctx);

    interface Builder { ... }  // Optional, when generateBuilders=true
}
```

**Key Characteristics:**
- Contains only method signatures, no implementation
- Declares all fields from all versions (union of fields)
- Fields not present in some versions return `null` or default values
- Nested message types are declared as nested interfaces

---

### Abstract Class

**Location:** `{basePackage}.api.impl`

**Purpose:** Implements shared logic using Template Method pattern. Concrete implementations only need to provide version-specific field extraction.

**Structure:**
```java
public abstract class Abstract{MessageName}<PROTO extends Message>
    implements {MessageName} {

    protected final PROTO proto;

    // Template methods (abstract) — implemented by subclasses
    protected abstract {Type} extract{Field}(PROTO proto);
    protected abstract boolean extractHas{Field}(PROTO proto);

    // Final implementations — delegate to template methods
    public final {Type} get{Field}() { ... }
    public final boolean has{Field}() { ... }

    // Common implementations
    public final String toString() { ... }
    public final boolean equals(Object obj) { ... }
    public final int hashCode() { ... }
}
```

**Key Characteristics:**
- Generic type parameter `PROTO` represents the version-specific protobuf class
- Holds immutable reference to underlying proto message
- All public methods are `final` to ensure consistent behavior
- `extract*` methods are the only version-specific code

---

### Implementation Class

**Location:** `{basePackage}.v1`, `{basePackage}.v2`, etc.

**Purpose:** Provides version-specific implementation by extracting values from the concrete protobuf message type.

**Structure:**
```java
public class {MessageName} extends Abstract{MessageName}<{Proto.MessageName}> {

    // Constructor
    public {MessageName}({Proto.MessageName} proto);

    // Static factory
    public static {MessageName} from({Proto.MessageName} proto);

    // Static builder factory (when generateBuilders=true)
    public static Builder newBuilder();

    // Typed proto access
    public {Proto.MessageName} getTypedProto();

    // Template method implementations
    @Override
    protected {Type} extract{Field}({Proto.MessageName} proto) { ... }
}
```

**Key Characteristics:**
- Extends abstract class with concrete proto type
- Implements all `extract*` template methods
- Provides typed access to underlying proto via `getTypedProto()`
- Contains nested `BuilderImpl` class when builders are enabled

---

### VersionContext

**Location:**
- Interface: `{basePackage}.api`
- Implementations: `{basePackage}.v1.VersionContextV1`, `{basePackage}.v2.VersionContextV2`, etc.

**Purpose:** Factory for creating wrapper instances of a specific protocol version. Provides a single entry point for all wrapper creation operations.

**Structure:**
```java
public interface VersionContext {
    // Static factory
    static VersionContext forVersion(int version);

    // Version info
    int getVersion();

    // For each message type:
    {MessageName} wrap{MessageName}(Message proto);
    {MessageName} parse{MessageName}FromBytes(byte[] bytes);
    {MessageName}.Builder new{MessageName}Builder();  // when generateBuilders=true

    // For nested types:
    {Parent}.{Nested}.Builder new{Parent}{Nested}Builder();
}
```

**Key Characteristics:**
- Singleton pattern — each version has one instance (`INSTANCE` field)
- Provides `wrap*` methods for wrapping existing proto messages
- Provides `parse*FromBytes` methods for deserializing from bytes
- Provides `new*Builder` methods for creating new instances
- Methods for types not present in a version throw `UnsupportedOperationException`

---

### Enum

**Location:** `{basePackage}.api`

**Purpose:** Unified enum type combining values from all protocol versions.

**Structure:**
```java
public enum {EnumName} {
    VALUE_ONE(0),
    VALUE_TWO(1),
    /** Present only in versions: [v2] */
    VALUE_THREE(2);  // Version-specific values are documented

    private final int value;

    {EnumName}(int value);

    public int getValue();
    public static {EnumName} fromProtoValue(int value);
}
```

**Conflict Enum** (generated for INT_ENUM conflicts):
```java
public enum {FieldName}Enum {
    // Same structure, but also includes:
    public static {EnumName} fromProtoValueOrDefault(int value, {EnumName} defaultValue);
    public static {EnumName} fromProtoValueOrThrow(int value);
}
```

---

## Generated Methods

### Field Accessors

#### get{Field}()

**Signature:** `{Type} get{Field}()`

**Purpose:** Returns the value of a message field.

**Behavior:**
- For required/singular fields: returns the value
- For optional fields not present: returns `null` (objects) or default (primitives)
- For repeated fields: returns unmodifiable `List<T>`, never `null`

---

#### has{Field}()

**Signature:** `boolean has{Field}()`

**Purpose:** Checks if an optional field has a value set.

**Generated for:** Optional fields only.

**Returns:** `true` if field has a value, `false` otherwise.

---

#### supports{Field}()

**Signature:** `default boolean supports{Field}()`

**Purpose:** Checks if this field exists in the current protocol version.

**Generated for:** Fields that exist only in some versions.

**Returns:** `true` if the current wrapper version supports this field.

**Use case:** Allows conditional logic based on field availability:
```java
if (wrapper.supportsNewField()) {
    // Safe to call getNewField()
}
```

---

### Version Information

#### getWrapperVersion()

**Signature:** `int getWrapperVersion()`

**Purpose:** Returns the protocol version number of this wrapper instance.

**Returns:** Version number (1, 2, 3, ...).

**Use case:** Runtime version detection for version-specific handling.

---

#### getContext()

**Signature:** `VersionContext getContext()`

**Purpose:** Returns the VersionContext for this wrapper's version.

**Use case:** Creating related objects of the same version:
```java
VersionContext ctx = order.getContext();
Money payment = ctx.newMoneyBuilder().setAmount(100).build();
```

---

### Serialization

#### toBytes()

**Signature:** `byte[] toBytes()`

**Purpose:** Serializes the wrapper to protobuf binary format.

**Returns:** Protobuf-encoded byte array.

**Use case:** Network transmission, storage, version conversion.

---

#### getTypedProto()

**Signature:** `{Proto.Type} getTypedProto()` (on implementation class only)

**Purpose:** Returns the underlying typed protobuf message.

**Use case:** Interoperability with code expecting raw proto objects.

---

### Version Conversion

#### asVersion(Class\<T\>)

**Signature:** `<T extends {Interface}> T asVersion(Class<T> versionClass)`

**Purpose:** Converts wrapper to a different version implementation.

**Mechanism:** Serializes to bytes, then deserializes with target version's parser.

**Data preservation:** All data is preserved via protobuf's unknown field handling. Fields not in target version become inaccessible through API but remain in the serialized form.

---

#### asVersionStrict(Class\<T\>)

**Signature:** `<T extends {Interface}> T asVersionStrict(Class<T> versionClass)`

**Purpose:** Strict conversion that fails if any populated fields would become inaccessible.

**Throws:** `IllegalStateException` if conversion would make fields inaccessible.

**Use case:** When data accessibility is critical and silent field inaccessibility is unacceptable.

---

#### getFieldsInaccessibleInVersion(int)

**Signature:** `List<String> getFieldsInaccessibleInVersion(int targetVersion)`

**Purpose:** Lists fields that have values but would become inaccessible in target version.

**Returns:** List of field names, empty if all fields remain accessible.

**Use case:** Pre-conversion validation, logging, user warnings.

---

#### canConvertLosslesslyTo(int)

**Signature:** `default boolean canConvertLosslesslyTo(int targetVersion)`

**Purpose:** Checks if conversion preserves accessibility of all populated fields.

**Returns:** `true` if `getFieldsInaccessibleInVersion(targetVersion).isEmpty()`.

---

### Builder Methods

Generated when `generateBuilders=true`.

#### newBuilder(VersionContext) — Static Factory

**Signature:** `static Builder newBuilder(VersionContext ctx)`

**Location:** On each interface (top-level and nested)

**Purpose:** Creates an empty builder using the specified version context.

**Parameters:**
- `ctx` — VersionContext determining the protocol version

**Returns:** Empty builder for creating new instances.

**Equivalence:** `Money.newBuilder(ctx)` is equivalent to `ctx.newMoneyBuilder()`.

**Use case:** More intuitive builder creation that mirrors the native protobuf pattern:
```java
// Native protobuf style
MyProto.MyMessage proto = MyProto.MyMessage.newBuilder()
        .setField("value")
        .build();

// Proto wrapper style (matches the pattern)
MyMessage wrapper = MyMessage.newBuilder(ctx)
        .setField("value")
        .build();
```

**Nested types:**
```java
// For nested interface Address.GeoLocation
Address.GeoLocation location = Address.GeoLocation.newBuilder(ctx)
        .setLatitude(40.7128)
        .setLongitude(-74.0060)
        .build();
```

---

#### toBuilder()

**Signature:** `Builder toBuilder()`

**Purpose:** Creates a builder initialized with current wrapper's values.

**Use case:** Creating modified copies of existing objects.

---

#### emptyBuilder()

**Signature:** `Builder emptyBuilder()`

**Purpose:** Creates an empty builder for the same version as this wrapper.

**Use case:** Creating new objects of the same version.

---

### Builder Interface Methods

#### set{Field}(value)

**Signature:** `Builder set{Field}({Type} value)`

**Purpose:** Sets the value of a field.

**Returns:** `this` for method chaining.

**Behavior for version-absent fields:** Throws `UnsupportedOperationException` with message indicating which versions support the field.

---

#### clear{Field}()

**Signature:** `Builder clear{Field}()`

**Purpose:** Clears an optional field to its default/unset state.

**Returns:** `this` for method chaining.

---

#### add{Field}(element) / addAll{Field}(list)

**Signature:** `Builder add{Field}({ElementType} element)`

**Purpose:** Adds element(s) to a repeated field.

**Generated for:** Repeated fields only.

---

#### build()

**Signature:** `{Interface} build()`

**Purpose:** Constructs the immutable wrapper instance.

**Returns:** New wrapper instance with builder's values.

---

## Type Conflict Resolution

When field types differ between protocol versions, the plugin generates unified accessors.

### INT_ENUM Conflict

**Condition:** Field is `int32` in some versions and `enum` in others.

**Generated methods:**

| Method | Returns | Purpose |
|--------|---------|---------|
| `get{Field}()` | `int` | Raw numeric value (works in all versions) |
| `get{Field}Enum()` | `{Field}Enum` | Type-safe enum value |

**Generated enum:** `{Field}Enum` with all enum values and `fromProtoValue()` converters.

---

### STRING_BYTES Conflict

**Condition:** Field is `string` in some versions and `bytes` in others.

**Generated methods:**

| Method | Returns | Purpose |
|--------|---------|---------|
| `get{Field}()` | `String` | String value (UTF-8 decoded for bytes) |
| `get{Field}Bytes()` | `byte[]` | Raw bytes (UTF-8 encoded for strings) |

---

### PRIMITIVE_MESSAGE Conflict

**Condition:** Field is primitive in some versions and message in others.

**Generated methods:**

| Method | Returns | Purpose |
|--------|---------|---------|
| `get{Field}()` | primitive type | Primitive value (0/default for message versions) |
| `get{Field}Message()` | message interface | Message value (null for primitive versions) |
| `supports{Field}()` | `boolean` | True if this version has primitive field |
| `supports{Field}Message()` | `boolean` | True if this version has message field |

---

### WIDENING Conflict

**Condition:** Field type widens between versions (e.g., `int32` → `int64`).

**Resolution:** Uses the wider type in the interface.

**Example:** `int32` in v1, `int64` in v2 → interface declares `long get{Field}()`.

---

## Nested Types

Nested protobuf messages are generated as nested interfaces/classes.

**Structure:**
```java
public interface {Parent} {

    interface {Nested} {
        // Field accessors

        // Static factory method (v1.1.1+)
        static Builder newBuilder(VersionContext ctx);

        interface Builder { ... }
    }

    {Nested} get{Nested}();
    boolean has{Nested}();
}
```

**Creating nested type instances:**

```java
// Using static newBuilder (recommended, v1.1.1+)
Address.GeoLocation location = Address.GeoLocation.newBuilder(ctx)
        .setLatitude(40.7128)
        .setLongitude(-74.0060)
        .build();

// Using VersionContext method (still works)
Address.GeoLocation location = ctx.newAddressGeoLocationBuilder()
        .setLatitude(40.7128)
        .setLongitude(-74.0060)
        .build();
```

**VersionContext methods for nested types:**
```java
{Parent}.{Nested}.Builder new{Parent}{Nested}Builder();
```

**Deep nesting:** Supported to arbitrary depth:
- Static method: `Parent.Child.GrandChild.newBuilder(ctx)`
- Context method: `ctx.newParentChildGrandChildBuilder()`

---

## Oneof Fields

Proto-wrapper provides full support for protobuf `oneof` fields, generating type-safe discriminator enums and appropriate accessor methods.

### Case Enum

For each oneof group, a nested Case enum is generated:

```java
public interface Payment {
    // Case enum for oneof 'method'
    enum MethodCase {
        CREDIT_CARD(10),
        BANK_TRANSFER(11),
        CRYPTO(12),           // V2 only
        METHOD_NOT_SET(0);

        private final int number;

        MethodCase(int number) { this.number = number; }
        public int getNumber() { return number; }

        public static MethodCase forNumber(int number) {
            for (MethodCase c : values()) {
                if (c.number == number) return c;
            }
            return METHOD_NOT_SET;
        }
    }

    // Discriminator method
    MethodCase getMethodCase();

    // Individual field checks
    boolean hasCreditCard();
    boolean hasBankTransfer();
    boolean hasCrypto();

    // Field accessors
    CreditCard getCreditCard();
    BankTransfer getBankTransfer();
    Crypto getCrypto();
}
```

### Usage Example

```java
VersionContext ctx = VersionContext.forVersion(1);

// Create with credit card
CreditCard card = ctx.newCreditCardBuilder()
        .setCardNumber("4111111111111111")
        .setExpiry("12/25")
        .build();

Payment payment = ctx.newPaymentBuilder()
        .setId("PAY-001")
        .setAmount(10000L)
        .setCreditCard(card)
        .build();

// Check which field is set
switch (payment.getMethodCase()) {
    case CREDIT_CARD -> handleCard(payment.getCreditCard());
    case BANK_TRANSFER -> handleTransfer(payment.getBankTransfer());
    case CRYPTO -> handleCrypto(payment.getCrypto());
    case METHOD_NOT_SET -> handleNoMethod();
}
```

### Builder Methods

```java
Payment.Builder builder = ctx.newPaymentBuilder()
        .setId("PAY-001")
        .setAmount(10000L);

// Set oneof field (replaces any previously set field)
builder.setCreditCard(card);
builder.setBankTransfer(transfer);  // Replaces credit card

// Clear oneof group
builder.clearMethod();  // All oneof fields become unset

Payment payment = builder.build();
```

### Version Differences

When oneof options differ between versions:

- **V1 has 2 options:** CREDIT_CARD, BANK_TRANSFER
- **V2 has 3 options:** CREDIT_CARD, BANK_TRANSFER, CRYPTO

The merged interface/enum includes all options from all versions. When converting:

- **V1 -> V2:** Works seamlessly, V1 fields are preserved
- **V2 -> V1 with CRYPTO:** Field is silently dropped (V1 doesn't support it)

---

### Oneof Conflict Detection

The plugin automatically detects and logs conflicts related to oneof fields across versions. Conflicts are logged at WARN level during code generation.

#### Conflict Types

| Conflict Type | Description | Example |
|--------------|-------------|---------|
| `PARTIAL_EXISTENCE` | Oneof exists only in some versions | V1: no oneof, V2: has oneof "method" |
| `FIELD_SET_DIFFERENCE` | Different fields in oneof across versions | V1: {credit_card, bank_transfer}, V2: adds {crypto} |
| `FIELD_TYPE_CONFLICT` | Type conflict within oneof field | V1: string text=1, V2: bytes text=1 |
| `RENAMED` | Oneof renamed between versions | V1: "payment_method", V2: "method" (same fields) |
| `FIELD_MEMBERSHIP_CHANGE` | Field moved in/out of oneof | V1: regular field, V2: inside oneof |
| `FIELD_NUMBER_CHANGE` | Field number changed | V1: credit_card=10, V2: credit_card=15 |
| `FIELD_REMOVED` | Field removed from oneof | V1: {credit_card, cash}, V2: {credit_card} only |
| `INCOMPATIBLE_TYPES` | Incompatible field types in oneof | Cannot be safely merged |

#### Renamed Oneof Detection

The plugin detects renamed oneofs by comparing field number sets:

```protobuf
// V1
message Payment {
    oneof payment_method {
        CreditCard credit_card = 10;
        BankTransfer bank_transfer = 11;
    }
}

// V2 - same fields, different oneof name
message Payment {
    oneof method {
        CreditCard credit_card = 10;
        BankTransfer bank_transfer = 11;
    }
}
```

When detected, the plugin:
1. Merges both oneofs into a single `MergedOneof`
2. Uses the most common name across versions
3. Logs a warning: `Oneof RENAMED: 'Payment.method' has different names: {v1=payment_method, v2=method}`

#### Field Membership Changes

Detects when a field moves in or out of a oneof:

```protobuf
// V1 - regular field
message Payment {
    CreditCard credit_card = 10;
}

// V2 - now inside oneof
message Payment {
    oneof method {
        CreditCard credit_card = 10;
        BankTransfer bank_transfer = 11;
    }
}
```

Warning: `Oneof MEMBERSHIP: 'Payment' - Field 'credit_card' (#10) moved into oneof in versions: [v2]`

#### Example Log Output

```
[WARN] Oneof PARTIAL: 'Payment.method' not in all versions - Missing in: [v1]
[WARN] Oneof FIELD_DIFF: 'Payment.method' - Field #12 present only in: [v2]
[WARN] Oneof RENAMED: 'Payment.method' has different names: {v1=payment_method, v2=method}
[WARN] Oneof MEMBERSHIP: 'Payment' - Field 'credit_card' (#10) moved into oneof
```

#### Accessing Conflict Information Programmatically

The `MergedOneof` class provides methods to query detected conflicts:

```java
MergedOneof oneof = mergedMessage.findOneofByName("method").orElseThrow();

// Check for conflicts
if (oneof.hasConflicts()) {
    List<OneofConflictInfo> conflicts = oneof.getConflicts();

    for (OneofConflictInfo conflict : conflicts) {
        System.out.println("Type: " + conflict.getType());
        System.out.println("Description: " + conflict.getDescription());
        System.out.println("Affected versions: " + conflict.getAffectedVersions());
    }
}

// Check for specific conflict type
if (oneof.hasConflictOfType(OneofConflictType.RENAMED)) {
    Set<String> names = oneof.getMergedFromNames();
    System.out.println("Oneof was renamed, original names: " + names);
}

// Check if oneof exists in all versions
Set<String> allVersions = Set.of("v1", "v2", "v3");
if (!oneof.isUniversal(allVersions)) {
    Set<String> missing = oneof.getMissingVersions(allVersions);
    System.out.println("Oneof missing in: " + missing);
}
```

---

## Thread Safety

- **Wrapper instances:** Immutable, thread-safe
- **Builder instances:** NOT thread-safe, use separate builder per thread
- **VersionContext:** Thread-safe singleton

---

## See Also

- [COOKBOOK.md](COOKBOOK.md) — Practical usage examples
- [KNOWN_ISSUES.md](KNOWN_ISSUES.md) — Limitations and workarounds
- [VERSION_AGNOSTIC_API.md](VERSION_AGNOSTIC_API.md) — Design philosophy
